/**
 * Investigation Service - Unified Investigation Management
 *
 * **BACKEND ARCHITECTURE**:
 * Olorin uses a unified investigation system with two backend implementations:
 *
 * 1. **InvestigationState System** (Database-Backed, PREFERRED):
 *    - Endpoint: `/api/v1/investigation-state/`
 *    - Persistent storage in database
 *    - Supports investigation lifecycle management
 *    - Provides real-time progress tracking
 *    - Used for structured and hybrid graph investigations
 *
 * 2. **Legacy Investigation System** (In-Memory, DEPRECATED - NOT USED):
 *    - Endpoint: `/api/investigation/{id}` (DEPRECATED - This service now uses investigation-state)
 *    - In-memory only (data lost on server restart)
 *    - Limited to basic CRUD operations
 *    - No lifecycle management
 *    - Scheduled for removal
 *
 * **UNIFIED ENDPOINTS**:
 * Some endpoints in `/api/investigations/` are unified and internally query the InvestigationState system:
 * - `/api/investigations/{id}/progress` - Real-time progress (unified)
 * - Other endpoints may still use the legacy system
 *
 * **USAGE**:
 * This service always uses the InvestigationState system (`/api/v1/investigation-state/`) for
 * creating investigations. Progress tracking uses the unified endpoint.
 *
 * **DATA TRANSFORMATION**:
 * - Backend sends snake_case JSON
 * - BaseApiService transforms to camelCase
 * - progressTransformer maps to TypeScript types
 *
 * @see BaseApiService for HTTP client and case conversion
 * @see progressTransformer for data transformation
 */

import { BaseApiService } from '@shared/services/BaseApiService';
import { getRuntimeConfig } from '../../../shared/config/runtimeConfig';
import { transformProgressResponse } from './progressTransformer';

export interface Investigation {
  id: string;
  title: string;
  description: string;
  type: 'fraud' | 'account_takeover' | 'device_spoofing' | 'compliance' | 'risk_assessment';
  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'cancelled';
  priority: 'low' | 'medium' | 'high' | 'critical';
  assignee?: string;
  createdAt: string;
  updatedAt: string;
  completedAt?: string;
  estimatedCompletion?: string;
  progress: number;
  findings?: InvestigationFinding[];
  evidence?: EvidenceItem[];
  metadata?: Record<string, any>;
}

export interface InvestigationFinding {
  id: string;
  type: 'risk' | 'anomaly' | 'violation' | 'suspicious_activity';
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  recommendation?: string;
  confidence: number;
  timestamp: string;
  agentId?: string;
  evidenceIds?: string[];
}

export interface EvidenceItem {
  id: string;
  type: 'log' | 'transaction' | 'device_data' | 'user_behavior' | 'network_data';
  source: string;
  title: string;
  description?: string;
  data: Record<string, any>;
  timestamp: string;
  investigationId: string;
  verified: boolean;
  tags?: string[];
}

export interface InvestigationParams {
  // Required fields
  id: string; // Investigation ID (generated by frontend)
  entityId: string; // Entity being investigated
  entityType: string; // Type of entity (user_id, device_id, auto, etc.)

  // Standard investigation parameters
  type?: Investigation['type'];
  title?: string;
  description?: string;
  priority?: Investigation['priority'];
  assignee?: string;
  metadata?: Record<string, any>;
  autoStart?: boolean;
  autoSelectEntities?: boolean; // Feature 006: Risk-based mode

  // Hybrid graph investigation parameters (Feature 006)
  investigationType?: 'structured' | 'hybrid-graph'; // Feature 006: Investigation type
  timeRange?: {
    start?: string;
    end?: string;
    type?: string; // e.g., 'last_180d'
    startDate?: string;
    endDate?: string;
  };
  tools?: Array<{
    tool_id: string;
    parameters?: Record<string, unknown>;
  }>;
}

export interface InvestigationUpdateParams {
  title?: string;
  description?: string;
  status?: Investigation['status'];
  priority?: Investigation['priority'];
  assignee?: string;
  progress?: number;
  metadata?: Record<string, any>;
}

export interface InvestigationFilters {
  type?: Investigation['type'] | Investigation['type'][];
  status?: Investigation['status'] | Investigation['status'][];
  priority?: Investigation['priority'] | Investigation['priority'][];
  assignee?: string;
  dateFrom?: string;
  dateTo?: string;
  search?: string;
}

export interface PaginatedInvestigations {
  investigations: Investigation[];
  totalCount: number;
  page: number;
  pageSize: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

export interface InvestigationStatistics {
  totalInvestigations: number;
  activeInvestigations: number;
  completedToday: number;
  averageCompletionTime: number;
  successRate: number;
  byType: Record<Investigation['type'], number>;
  byStatus: Record<Investigation['status'], number>;
  byPriority: Record<Investigation['priority'], number>;
}

// Module-level request deduplication for getProgress and getInvestigation
// Prevents multiple simultaneous calls for the same investigation ID
// Works across React StrictMode remounts and multiple hook instances
const progressFetchMap = new Map<string, Promise<{ data: import('../../../shared/types/investigation').InvestigationProgress | null; etag: string | null }>>();
const investigationFetchMap = new Map<string, Promise<Investigation>>();
const isProgressFetchInProgress = new Map<string, boolean>();
const isInvestigationFetchInProgress = new Map<string, boolean>();

export class InvestigationService extends BaseApiService {
  private readonly baseEndpoint = '/api/v1/investigation-state';

  constructor(baseUrl?: string) {
    // SYSTEM MANDATE Compliance: Use runtime config with fail-fast validation
    // If baseUrl is provided (for testing), use it. Otherwise, get from config.
    // CRITICAL: Fail-fast if config is missing (no hardcoded fallback)
    const apiUrl = baseUrl || getRuntimeConfig('REACT_APP_API_BASE_URL', { required: true });
    super(apiUrl);
  }

  /**
   * Creates a new investigation using the InvestigationState system
   *
   * **ENDPOINT**: `/api/v1/investigation-state/` (Database-backed, persistent)
   *
   * **FEATURES**:
   * - Persistent database storage
   * - Lifecycle management (IN_PROGRESS â†’ COMPLETED/FAILED)
   * - Real-time progress tracking
   * - Support for both structured and hybrid graph investigations
   * - Risk-based entity auto-selection (when entityType='auto')
   *
   * **REQUEST TRANSFORMATION**:
   * - Frontend sends: camelCase (params)
   * - BaseApiService transforms to: snake_case (requestBody)
   * - Backend receives: snake_case InvestigationStateCreate model
   *
   * **RESPONSE TRANSFORMATION**:
   * - Backend sends: snake_case JSON
   * - BaseApiService transforms to: camelCase
   * - Returns: Investigation (TypeScript type)
   *
   * @param params - Investigation parameters (camelCase)
   * @returns Promise<Investigation> - Created investigation (camelCase)
   *
   * @example
   * ```typescript
   * // Structured investigation with specific entity
   * const investigation = await investigationService.createInvestigation({
   *   id: 'inv-123',
   *   entityType: 'user_id',
   *   entityId: 'user-456',
   *   title: 'Fraud Investigation',
   *   timeRange: { start: '2025-01-01', end: '2025-01-07' },
   *   tools: [{ tool_id: 'device_analysis' }]
   * });
   *
   * // Hybrid graph investigation with risk-based auto-selection
   * const autoInvestigation = await investigationService.createInvestigation({
   *   id: 'inv-789',
   *   entityType: 'auto',
   *   entityId: 'risk-based-auto',
   *   title: 'Risk-Based Investigation',
   *   timeRange: { type: 'last_180d' },
   *   tools: [], // LLM will auto-select tools
   *   autoSelectEntities: true
   * });
   * ```
   */
  async createInvestigation(params: InvestigationParams): Promise<Investigation> {
    // Use the proper investigation state endpoint for state-managed investigations
    const stateEndpoint = '/api/v1/investigation-state/';

    // Map frontend investigation type to backend format
    // Frontend uses 'hybrid-graph', backend expects 'hybrid'
    const backendInvestigationType = params.investigationType === 'hybrid-graph'
      ? 'hybrid'
      : (params.investigationType || 'structured');

    // Transform params to match InvestigationStateCreate schema
    // Handle risk-based mode with proper null values instead of placeholders
    const isRiskBased = params.autoSelectEntities === true || params.entityType === 'auto';

    const requestBody = {
      investigation_id: params.id,
      lifecycle_stage: 'IN_PROGRESS',
      status: 'IN_PROGRESS',
      settings: {
        name: params.title || `Investigation ${params.id}`,
        entities: isRiskBased ? [{
          entity_type: null,
          entity_value: null
        }] : [{
          entity_type: params.entityType,
          entity_value: params.entityId
        }],
        time_range: params.timeRange || {},
        tools: params.tools || [],
        correlation_mode: 'OR',
        investigation_type: backendInvestigationType, // Map 'hybrid-graph' -> 'hybrid'
        investigation_mode: isRiskBased ? 'risk' : 'entity', // Add investigation mode
        auto_select_entities: isRiskBased // Add flag for risk-based mode
      }
    };

    return this.post<Investigation>(stateEndpoint, requestBody);
  }

  async getInvestigation(id: string): Promise<Investigation> {
    // Request deduplication: prevent multiple simultaneous calls for the same investigation ID
    // This prevents duplicate calls from useInvestigationSnapshot and other hooks
    
    // Check if there's already a pending request for this investigation ID
    const pendingRequest = investigationFetchMap.get(id);
    if (pendingRequest) {
      console.log('ðŸ”„ [InvestigationService.getInvestigation] Reusing pending request for ID:', id);
      return pendingRequest;
    }
    
    // Mark fetch as in progress for this investigation ID
    isInvestigationFetchInProgress.set(id, true);
    
    // Create the fetch promise
    const fetchPromise = (async () => {
      try {
        return await this.get<Investigation>(`${this.baseEndpoint}/${id}`);
      } finally {
        // Cleanup: Remove from maps when request completes
        investigationFetchMap.delete(id);
        isInvestigationFetchInProgress.delete(id);
      }
    })();
    
    // Store the promise in the map for deduplication
    investigationFetchMap.set(id, fetchPromise);
    
    return fetchPromise;
  }

  async updateInvestigation(id: string, params: InvestigationUpdateParams): Promise<Investigation> {
    return this.patch<Investigation>(`${this.baseEndpoint}/${id}`, params);
  }

  async deleteInvestigation(id: string): Promise<void> {
    return this.delete(`${this.baseEndpoint}/${id}`);
  }

  async getInvestigations(
    filters?: InvestigationFilters,
    page: number = 1,
    pageSize: number = 20
  ): Promise<PaginatedInvestigations> {
    const params = new URLSearchParams();

    if (filters) {
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          if (Array.isArray(value)) {
            value.forEach(v => params.append(`${key}[]`, v.toString()));
          } else {
            params.append(key, value.toString());
          }
        }
      });
    }

    params.append('page', page.toString());
    params.append('pageSize', pageSize.toString());

    return this.get<PaginatedInvestigations>(`${this.baseEndpoint}?${params.toString()}`);
  }

  async startInvestigation(id: string): Promise<Investigation> {
    return this.post<Investigation>(`${this.baseEndpoint}/${id}/start`);
  }

  async restartInvestigation(id: string): Promise<Investigation> {
    return this.post<Investigation>(`${this.baseEndpoint}/${id}/restart`);
  }

  async pauseInvestigation(id: string): Promise<Investigation> {
    return this.post<Investigation>(`${this.baseEndpoint}/${id}/pause`);
  }

  async resumeInvestigation(id: string): Promise<Investigation> {
    return this.post<Investigation>(`${this.baseEndpoint}/${id}/resume`);
  }

  async cancelInvestigation(id: string, reason?: string): Promise<Investigation> {
    return this.post<Investigation>(`${this.baseEndpoint}/${id}/cancel`, { reason });
  }

  async completeInvestigation(id: string, summary?: string): Promise<Investigation> {
    return this.post<Investigation>(`${this.baseEndpoint}/${id}/complete`, { summary });
  }

  async getInvestigationFindings(id: string): Promise<InvestigationFinding[]> {
    return this.get<InvestigationFinding[]>(`${this.baseEndpoint}/${id}/findings`);
  }

  async addInvestigationFinding(id: string, finding: Omit<InvestigationFinding, 'id' | 'timestamp'>): Promise<InvestigationFinding> {
    return this.post<InvestigationFinding>(`${this.baseEndpoint}/${id}/findings`, finding);
  }

  async getInvestigationEvidence(id: string): Promise<EvidenceItem[]> {
    return this.get<EvidenceItem[]>(`${this.baseEndpoint}/${id}/evidence`);
  }

  async addEvidence(id: string, evidence: Omit<EvidenceItem, 'id' | 'timestamp' | 'investigationId'>): Promise<EvidenceItem> {
    return this.post<EvidenceItem>(`${this.baseEndpoint}/${id}/evidence`, evidence);
  }

  async verifyEvidence(investigationId: string, evidenceId: string, verified: boolean): Promise<EvidenceItem> {
    return this.patch<EvidenceItem>(`${this.baseEndpoint}/${investigationId}/evidence/${evidenceId}`, { verified });
  }

  async getInvestigationStatistics(timeframe?: 'day' | 'week' | 'month' | 'year'): Promise<InvestigationStatistics> {
    const params = timeframe ? `?timeframe=${timeframe}` : '';
    return this.get<InvestigationStatistics>(`${this.baseEndpoint}/statistics${params}`);
  }

  async exportInvestigation(id: string, format: 'pdf' | 'json' | 'csv' = 'pdf'): Promise<Blob> {
    const response = await this.fetch(`${this.baseEndpoint}/${id}/export?format=${format}`, {
      method: 'GET',
      headers: {
        ...this.getAuthHeaders(),
      },
    });

    if (!response.ok) {
      throw new Error(`Export failed: ${response.statusText}`);
    }

    return response.blob();
  }

  async duplicateInvestigation(id: string, title?: string): Promise<Investigation> {
    return this.post<Investigation>(`${this.baseEndpoint}/${id}/duplicate`, { title });
  }

  async getInvestigationHistory(id: string): Promise<any[]> {
    return this.get<any[]>(`${this.baseEndpoint}/${id}/history`);
  }

  async assignInvestigation(id: string, assigneeId: string): Promise<Investigation> {
    return this.patch<Investigation>(`${this.baseEndpoint}/${id}/assign`, { assigneeId });
  }

  async unassignInvestigation(id: string): Promise<Investigation> {
    return this.patch<Investigation>(`${this.baseEndpoint}/${id}/unassign`);
  }

  async addComment(id: string, comment: string): Promise<any> {
    return this.post(`${this.baseEndpoint}/${id}/comments`, { comment });
  }

  async getComments(id: string): Promise<any[]> {
    return this.get<any[]>(`${this.baseEndpoint}/${id}/comments`);
  }

  /**
   * Gets investigation progress data for real-time monitoring
   *
   * **ENDPOINT**: `/api/investigation/{id}/progress` (Unified, database-backed)
   *
   * **BACKEND IMPLEMENTATION**:
   * This endpoint is unified and internally queries the InvestigationState system:
   * - Queries database via `get_state_by_id()`
   * - Builds progress from `InvestigationProgressService.build_progress_from_state()`
   * - Supports ETag caching for efficient polling
   *
   * **FEATURES**:
   * - Real-time progress tracking (0-100%)
   * - Tool execution status (queued/running/completed/failed)
   * - Agent progress and risk scores
   * - Phase tracking with completion percentages
   * - Entity relationships and metadata
   * - ETag support for conditional requests (304 Not Modified)
   *
   * **DATA FLOW**:
   * 1. Backend sends: snake_case JSON (e.g., completion_percent, total_tools)
   * 2. BaseApiService transforms to: camelCase (e.g., completionPercent, totalTools)
   * 3. transformProgressResponse() maps to: InvestigationProgress (TypeScript type)
   * 4. Returns: Fully typed progress object
   *
   * **POLLING**:
   * This method is designed for polling:
   * - Poll every 1-2 seconds during investigation
   * - ETag support reduces bandwidth when no changes
   * - Returns 304 Not Modified when progress unchanged
   *
   * Feature: 007-progress-wizard-page, 008-live-investigation-updates
   *
   * @param id - Investigation ID
   * @returns Promise<InvestigationProgress> - Progress data with tool executions, agent statuses, etc.
   *
   * @example
   * ```typescript
   * // Poll for progress updates
   * const pollProgress = async (investigationId: string) => {
   *   const intervalId = setInterval(async () => {
   *     try {
   *       const progress = await investigationService.getProgress(investigationId);
   *
   *       console.log(`Progress: ${progress.completionPercent}%`);
   *       console.log(`Tools: ${progress.completedTools}/${progress.totalTools}`);
   *       console.log(`Phase: ${progress.lifecycleStage}`);
   *
   *       if (progress.lifecycleStage === 'completed') {
   *         clearInterval(intervalId);
   *         console.log('Investigation completed!');
   *       }
   *     } catch (error) {
   *       console.error('Failed to fetch progress:', error);
   *     }
   *   }, 2000); // Poll every 2 seconds
   * };
   * ```
   */
  async getProgress(id: string, etag?: string | null): Promise<{ data: import('../../../shared/types/investigation').InvestigationProgress | null; etag: string | null }> {
    // Request deduplication: prevent multiple simultaneous calls for the same investigation ID
    // Deduplicate based on ID only (ignore ETag differences for concurrent calls)
    // This prevents 5-6 consecutive calls when investigation starts
    
    // Check if there's already a pending request for this investigation ID
    const pendingRequest = progressFetchMap.get(id);
    if (pendingRequest) {
      console.log('ðŸ”„ [InvestigationService.getProgress] Reusing pending request for ID:', id);
      return pendingRequest;
    }
    
    // Mark fetch as in progress for this investigation ID
    isProgressFetchInProgress.set(id, true);
    
    // Create the fetch promise
    const fetchPromise = (async () => {
      try {
        console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService.getProgress] Called with ID:', id, 'ETag:', etag);
        console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService.getProgress] Full endpoint:', `${this.baseEndpoint}/${id}`);

        // Build headers with ETag if provided
        const headers: Record<string, string> = {};
        if (etag) {
          headers['If-None-Match'] = etag;
        }

        // Use cache-busting query parameter to prevent 304 Not Modified on browser refresh
        // This avoids CORS preflight issues that custom headers would cause
        const cacheBuster = `_t=${Date.now()}`;
        const url = `${this.baseEndpoint}/${id}?${cacheBuster}`;

        // Use fetch directly to access response headers for ETag
        const response = await this.fetch(url, {
          method: 'GET',
          headers: headers
        });
      
      // Extract ETag from response headers
      const responseETag = response.headers.get('ETag') || response.headers.get('etag') || null;
      
      // Handle 304 Not Modified - return null data with existing ETag
      if (response.status === 304) {
        console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService.getProgress] 304 Not Modified - no changes');
        return { data: null, etag: etag || responseETag };
      }
      
      // Parse response data
      const responseData = await response.json();
      // Transform snake_case to camelCase (same as BaseApiService.get())
      const { snakeToCamel } = await import('../../../shared/utils/caseConversion');
      const result = responseData.data || responseData;
      const investigationState = snakeToCamel<any>(result);

      console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] Raw backend response:', investigationState);
      console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] Raw response keys:', Object.keys(investigationState || {}));
      console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] investigationId check:', {
        investigationId: investigationState.investigationId,
        investigation_id: investigationState.investigation_id,
        id: investigationState.id
      });

      // Extract progress object from investigation state response
      // BaseApiService.get() already transforms snake_case to camelCase, so:
      // - investigation_id â†’ investigationId
      // - domain_findings â†’ domainFindings
      // - tool_executions â†’ toolExecutions
      // - tools_executed â†’ toolsExecuted
      const progressData = investigationState.progress || {};
      
      console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] Progress data keys:', Object.keys(progressData || {}));
      console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] Domain findings check:', {
        domainFindings: !!progressData.domainFindings,
        domainFindingsKeys: progressData.domainFindings ? Object.keys(progressData.domainFindings) : []
      });
      
      // Handle toolExecutions - BaseApiService transforms tool_executions â†’ toolExecutions
      // Backend may provide:
      // 1. tool_executions (array of objects) â†’ toolExecutions (camelCase)
      // 2. tools_executed (array of strings) â†’ toolsExecuted (camelCase)
      // Check both camelCase (from BaseApiService) and snake_case (fallback)
      let toolExecutions = progressData.toolExecutions || progressData.tool_executions || [];
      
      // If toolExecutions is empty, check for toolsExecuted (array of strings)
      // BaseApiService transforms tools_executed â†’ toolsExecuted
      if (toolExecutions.length === 0) {
        const toolsExecuted = progressData.toolsExecuted || progressData.tools_executed;
        if (toolsExecuted && Array.isArray(toolsExecuted) && toolsExecuted.length > 0) {
          toolExecutions = toolsExecuted; // Will be handled by mapToolExecutions to convert strings to objects
          console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] Using toolsExecuted array:', {
            count: toolsExecuted.length,
            tools: toolsExecuted
          });
        }
      }
      
      // Calculate tool stats - use actual toolExecutions length if backend doesn't provide counts
      const toolsExecutedCount = toolExecutions.length || progressData.toolsExecuted?.length || progressData.tools_executed?.length || 0;
      
      console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] Tool extraction:', {
        toolExecutionsLength: toolExecutions.length,
        toolsExecutedLength: progressData.toolsExecuted?.length || progressData.tools_executed?.length || 0,
        toolsExecutedCount,
        toolExecutionsType: toolExecutions.length > 0 ? typeof toolExecutions[0] : 'empty'
      });
      
      // Build backend progress response structure expected by transformer
      // BaseApiService transforms investigation_id â†’ investigationId, so check camelCase FIRST
      const investigationId = investigationState.investigationId || investigationState.investigation_id || investigationState.id;
      
      if (!investigationId) {
        console.error('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] CRITICAL: No investigation ID found!', {
          availableKeys: Object.keys(investigationState || {}),
          investigationState: investigationState
        });
      }
      
      const backendData = {
        id: investigationId || 'unknown',
        investigationId: investigationId || 'unknown',
        // Also include snake_case version for transformer fallback
        investigation_id: investigationId || 'unknown',
        status: investigationState.status,
        lifecycleStage: investigationState.lifecycle_stage || investigationState.lifecycleStage,
        completionPercent: progressData.completionPercent || progressData.percentComplete || progressData.progressPercentage || progressData.percent_complete || 0,
        createdAt: investigationState.createdAt || investigationState.created_at,
        // Extract startedAt from progress_json if not at top level
        startedAt: investigationState.startedAt || investigationState.started_at ||
                   (progressData.startedAt || progressData.started_at || null),
        completedAt: investigationState.completedAt || investigationState.completed_at || null,
        lastUpdatedAt: investigationState.updatedAt || investigationState.lastUpdatedAt || investigationState.updated_at,
        toolExecutions: toolExecutions,
        // Use actual toolExecutions length if backend doesn't provide explicit counts
        totalTools: progressData.totalTools || progressData.total_tools || toolsExecutedCount,
        completedTools: progressData.completedTools || progressData.completed_tools || (toolExecutions.length > 0 ? toolExecutions.length : 0),
        runningTools: progressData.runningTools || progressData.running_tools || 0,
        queuedTools: progressData.queuedTools || progressData.queued_tools || 0,
        failedTools: progressData.failedTools || progressData.failed_tools || 0,
        skippedTools: progressData.skippedTools || progressData.skipped_tools || 0,
        agentStatuses: progressData.agentStatuses || progressData.agent_statuses,
        riskMetrics: progressData.riskMetrics || progressData.risk_metrics,
        phases: progressData.phases || [],
        currentPhase: progressData.currentPhase || progressData.current_phase || null,
        // CRITICAL FIX: Entities are in settings.entities, not progress.entities
        entities: investigationState.settings?.entities || progressData.entities || [],
        relationships: progressData.relationships || [],
        toolsPerSecond: progressData.toolsPerSecond || progressData.tools_per_second || 0,
        peakToolsPerSecond: progressData.peakToolsPerSecond || progressData.peak_tools_per_second || 0,
        iceConnected: progressData.iceConnected || progressData.ice_connected || false,
        errors: progressData.errors || [],
        // CRITICAL: Extract domainFindings from progress object (BaseApiService transforms domain_findings â†’ domainFindings)
        domainFindings: progressData.domainFindings || progressData.domain_findings || {},
        // Include settings for full investigation state context
        settings: investigationState.settings || null
      };

      console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] Backend data prepared:', {
        hasDomainFindings: !!backendData.domainFindings && Object.keys(backendData.domainFindings).length > 0,
        domainFindingsCount: backendData.domainFindings ? Object.keys(backendData.domainFindings).length : 0,
        toolExecutionsCount: backendData.toolExecutions.length,
        toolExecutionsType: Array.isArray(backendData.toolExecutions) ? (backendData.toolExecutions.length > 0 ? typeof backendData.toolExecutions[0] : 'empty') : 'not-array'
      });

      const transformedData = transformProgressResponse(backendData);

      console.log('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] After transformation:', {
        hasData: !!transformedData,
        status: transformedData.status,
        lifecycleStage: transformedData.lifecycleStage,
        id: transformedData.id,
        investigationId: transformedData.investigationId,
        hasDomainFindings: !!(transformedData as any).domainFindings && Object.keys((transformedData as any).domainFindings || {}).length > 0,
        domainFindingsCount: (transformedData as any).domainFindings ? Object.keys((transformedData as any).domainFindings).length : 0
      });

        return { data: transformedData, etag: responseETag };
      } catch (error) {
        console.error('ðŸš¨ðŸš¨ðŸš¨ [InvestigationService] Error in getProgress:', error);
        throw error;
      } finally {
        // Cleanup: Remove from maps when request completes
        progressFetchMap.delete(id);
        isProgressFetchInProgress.delete(id);
      }
    })();
    
    // Store the promise in the map for deduplication
    progressFetchMap.set(id, fetchPromise);
    
    return fetchPromise;
  }

  async subscribeToUpdates(id: string, callback: (investigation: Investigation) => void): Promise<() => void> {
    // Polling-based updates (spec 005 - WebSocket removed)
    const pollInterval = 2000; // Poll every 2 seconds
    let isActive = true;
    let lastUpdated: string | null = null;

    const poll = async () => {
      if (!isActive) return;

      try {
        const investigation = await this.getInvestigation(id);

        // Only trigger callback if investigation has changed
        if (lastUpdated !== investigation.updatedAt) {
          lastUpdated = investigation.updatedAt;
          callback(investigation);
        }

        // Continue polling if still active
        if (isActive) {
          setTimeout(poll, pollInterval);
        }
      } catch (error) {
        console.error('Failed to poll investigation updates:', error);

        // Retry with exponential backoff on error
        if (isActive) {
          setTimeout(poll, pollInterval * 2);
        }
      }
    };

    // Start polling
    poll();

    // Return cleanup function
    return () => {
      isActive = false;
    };
  }

  /**
   * Triggers the startup analysis flow manually
   * 
   * @param topN Number of top entities to process (default: 3)
   * @param forceRefresh Whether to force refresh risk entities (default: false)
   */
  async triggerStartupAnalysis(topN: number = 3, forceRefresh: boolean = false): Promise<any> {
    const params = new URLSearchParams();
    params.append('top_n', topN.toString());
    params.append('force_refresh', forceRefresh.toString());
    
    return this.post(`/api/v1/analytics/startup-analysis/trigger?${params.toString()}`);
  }

  async generateConfusionMatrix(id: string): Promise<{ url: string; filename: string }> {
    return this.post<{ url: string; filename: string }>(`${this.baseEndpoint}/${id}/confusion-matrix`);
  }

  async generateStartupAnalysisReport(): Promise<{ message: string; report_path: string; download_url: string }> {
    return this.post<{ message: string; report_path: string; download_url: string }>('/api/v1/reports/startup-analysis/generate');
  }
}

// Lazy singleton - only instantiate when first accessed, after config is initialized
let investigationServiceInstance: InvestigationService | null = null;

function getInstance(): InvestigationService {
  if (!investigationServiceInstance) {
    investigationServiceInstance = new InvestigationService();
  }
  return investigationServiceInstance;
}

// Export direct access to instance for full API access
export const investigationService = {
  // Direct instance access - use this when you need full InvestigationService API
  get instance(): InvestigationService {
    return getInstance();
  },

  // Convenience proxy methods for common operations
  createInvestigation: (...args: Parameters<InvestigationService['createInvestigation']>) =>
    getInstance().createInvestigation(...args),
  getInvestigation: (...args: Parameters<InvestigationService['getInvestigation']>) =>
    getInstance().getInvestigation(...args),
  updateInvestigation: (...args: Parameters<InvestigationService['updateInvestigation']>) =>
    getInstance().updateInvestigation(...args),
  deleteInvestigation: (...args: Parameters<InvestigationService['deleteInvestigation']>) =>
    getInstance().deleteInvestigation(...args),
  getInvestigations: (...args: Parameters<InvestigationService['getInvestigations']>) =>
    getInstance().getInvestigations(...args),
  startInvestigation: (...args: Parameters<InvestigationService['startInvestigation']>) =>
    getInstance().startInvestigation(...args),
  restartInvestigation: (...args: Parameters<InvestigationService['restartInvestigation']>) =>
    getInstance().restartInvestigation(...args),
  pauseInvestigation: (...args: Parameters<InvestigationService['pauseInvestigation']>) =>
    getInstance().pauseInvestigation(...args),
  resumeInvestigation: (...args: Parameters<InvestigationService['resumeInvestigation']>) =>
    getInstance().resumeInvestigation(...args),
  cancelInvestigation: (...args: Parameters<InvestigationService['cancelInvestigation']>) =>
    getInstance().cancelInvestigation(...args),
  completeInvestigation: (...args: Parameters<InvestigationService['completeInvestigation']>) =>
    getInstance().completeInvestigation(...args),
  getInvestigationFindings: (...args: Parameters<InvestigationService['getInvestigationFindings']>) =>
    getInstance().getInvestigationFindings(...args),
  addInvestigationFinding: (...args: Parameters<InvestigationService['addInvestigationFinding']>) =>
    getInstance().addInvestigationFinding(...args),
  getInvestigationEvidence: (...args: Parameters<InvestigationService['getInvestigationEvidence']>) =>
    getInstance().getInvestigationEvidence(...args),
  addEvidence: (...args: Parameters<InvestigationService['addEvidence']>) =>
    getInstance().addEvidence(...args),
  verifyEvidence: (...args: Parameters<InvestigationService['verifyEvidence']>) =>
    getInstance().verifyEvidence(...args),
  getInvestigationStatistics: (...args: Parameters<InvestigationService['getInvestigationStatistics']>) =>
    getInstance().getInvestigationStatistics(...args),
  exportInvestigation: (...args: Parameters<InvestigationService['exportInvestigation']>) =>
    getInstance().exportInvestigation(...args),
  duplicateInvestigation: (...args: Parameters<InvestigationService['duplicateInvestigation']>) =>
    getInstance().duplicateInvestigation(...args),
  getInvestigationHistory: (...args: Parameters<InvestigationService['getInvestigationHistory']>) =>
    getInstance().getInvestigationHistory(...args),
  assignInvestigation: (...args: Parameters<InvestigationService['assignInvestigation']>) =>
    getInstance().assignInvestigation(...args),
  unassignInvestigation: (...args: Parameters<InvestigationService['unassignInvestigation']>) =>
    getInstance().unassignInvestigation(...args),
  addComment: (...args: Parameters<InvestigationService['addComment']>) =>
    getInstance().addComment(...args),
  getComments: (...args: Parameters<InvestigationService['getComments']>) =>
    getInstance().getComments(...args),
  getProgress: (...args: Parameters<InvestigationService['getProgress']>) =>
    getInstance().getProgress(...args),
  subscribeToUpdates: (...args: Parameters<InvestigationService['subscribeToUpdates']>) =>
    getInstance().subscribeToUpdates(...args),
  triggerStartupAnalysis: (...args: Parameters<InvestigationService['triggerStartupAnalysis']>) =>
    getInstance().triggerStartupAnalysis(...args),
  generateConfusionMatrix: (...args: Parameters<InvestigationService['generateConfusionMatrix']>) =>
    getInstance().generateConfusionMatrix(...args),
  generateStartupAnalysisReport: (...args: Parameters<InvestigationService['generateStartupAnalysisReport']>) =>
    getInstance().generateStartupAnalysisReport(...args),
};
