/**
 * UnifiedLog TypeScript Interface and Zod Schema
 * Feature: 021-live-merged-logstream
 *
 * Normalized log record for real-time merged streaming across frontend and backend.
 * Provides runtime validation with Zod and type-safe interfaces.
 *
 * Author: Gil Klainert
 * Date: 2025-11-12
 * Spec: /specs/021-live-merged-logstream/data-model.md
 */

import { z } from 'zod';

/**
 * Log level enumeration
 */
export type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';

/**
 * Log source enumeration
 */
export type LogSource = 'frontend' | 'backend';

/**
 * Unified log entry interface
 */
export interface UnifiedLog {
  // Identity
  event_id: string;

  // Timestamp and ordering
  ts: string; // ISO 8601 timestamp
  seq: number; // Monotonic sequence number

  // Source identification
  source: LogSource;
  service: string;

  // Log content
  level: LogLevel;
  message: string;

  // Correlation
  investigation_id: string;
  correlation_id?: string;

  // Additional context
  context: Record<string, any>;

  // Metadata
  schema_version: number;
}

/**
 * Zod schema for UnifiedLog runtime validation
 *
 * Validates:
 * - UUID format for event_id
 * - ISO 8601 datetime for ts
 * - Non-negative integer for seq
 * - Valid enum values for source and level
 * - String length constraints
 * - Required vs optional fields
 */
export const UnifiedLogSchema = z.object({
  // Identity
  event_id: z.string().uuid({
    message: 'event_id must be a valid UUID'
  }),

  // Timestamp and ordering
  ts: z.string().datetime({
    message: 'ts must be a valid ISO 8601 datetime'
  }),
  seq: z.number().int().nonnegative({
    message: 'seq must be a non-negative integer'
  }),

  // Source identification
  source: z.enum(['frontend', 'backend'], {
    errorMap: () => ({ message: 'source must be "frontend" or "backend"' })
  }),
  service: z.string().min(1, {
    message: 'service must be at least 1 character'
  }),

  // Log content
  level: z.enum(['DEBUG', 'INFO', 'WARN', 'ERROR'], {
    errorMap: () => ({ message: 'level must be DEBUG, INFO, WARN, or ERROR' })
  }),
  message: z.string().min(1).max(10000, {
    message: 'message must be between 1 and 10000 characters'
  }),

  // Correlation
  investigation_id: z.string().min(1, {
    message: 'investigation_id must be at least 1 character'
  }),
  correlation_id: z.string().optional(),

  // Additional context
  context: z.record(z.any()).default({}),

  // Metadata
  schema_version: z.number().int().default(1)
});

/**
 * Type inference from Zod schema (ensures consistency)
 */
export type UnifiedLogValidated = z.infer<typeof UnifiedLogSchema>;

/**
 * Schema for creating new UnifiedLog entries (for log ingestion)
 * event_id is optional (will be auto-generated by backend if not provided)
 */
export const UnifiedLogCreateSchema = z.object({
  event_id: z.string().uuid().optional(),
  ts: z.string().datetime(),
  seq: z.number().int().nonnegative().default(0),
  source: z.enum(['frontend', 'backend']),
  service: z.string().min(1),
  level: z.enum(['DEBUG', 'INFO', 'WARN', 'ERROR']),
  message: z.string().min(1).max(10000),
  investigation_id: z.string().min(1),
  correlation_id: z.string().optional(),
  context: z.record(z.any()).default({}),
  schema_version: z.number().int().default(1)
});

/**
 * Type for creating UnifiedLog entries
 */
export type UnifiedLogCreate = z.infer<typeof UnifiedLogCreateSchema>;

/**
 * Validate UnifiedLog data at runtime
 *
 * @param data - Data to validate
 * @returns Validated UnifiedLog or throws ZodError
 */
export function validateUnifiedLog(data: unknown): UnifiedLog {
  return UnifiedLogSchema.parse(data);
}

/**
 * Safe validation that returns result object instead of throwing
 *
 * @param data - Data to validate
 * @returns Success with data or error with issues
 */
export function safeValidateUnifiedLog(data: unknown): {
  success: true;
  data: UnifiedLog;
} | {
  success: false;
  error: z.ZodError;
} {
  const result = UnifiedLogSchema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  } else {
    return { success: false, error: result.error };
  }
}

/**
 * Create a UnifiedLog entry for frontend logging
 *
 * @param params - Log parameters
 * @returns UnifiedLogCreate object ready for ingestion
 */
export function createFrontendLog(params: {
  level: LogLevel;
  message: string;
  investigation_id: string;
  service?: string;
  correlation_id?: string;
  context?: Record<string, any>;
}): UnifiedLogCreate {
  return {
    ts: new Date().toISOString(),
    seq: 0, // Backend will assign proper sequence
    source: 'frontend',
    service: params.service || 'react-app',
    level: params.level,
    message: params.message,
    investigation_id: params.investigation_id,
    correlation_id: params.correlation_id,
    context: params.context || {},
    schema_version: 1
  };
}

export default UnifiedLogSchema;
