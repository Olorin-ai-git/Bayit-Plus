# =============================================================================
# Olorin Backend - Deploy to Production
# =============================================================================
# Deploys to production on release tags (v*.*.*)
# Requires manual approval for safety
# =============================================================================

name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag to deploy (e.g., v1.2.3)'
        required: true
        type: string
      skip_staging_check:
        description: 'Skip staging verification'
        required: false
        type: boolean
        default: false

env:
  PROJECT_ID: olorin-fraud-detection
  REGION: us-east1
  SERVICE_NAME: olorin-backend-production
  ARTIFACT_REGISTRY: us-east1-docker.pkg.dev
  REPOSITORY: olorin
  IMAGE_NAME: backend

concurrency:
  group: deploy-production
  cancel-in-progress: false  # Never cancel production deployments

jobs:
  # ===========================================================================
  # Verify Staging is Healthy
  # ===========================================================================
  verify-staging:
    name: Verify Staging
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_staging_check }}
    timeout-minutes: 5

    steps:
      - name: Check staging health
        run: |
          STAGING_URL="https://olorin-backend-staging-${REGION}.run.app"

          echo "Checking staging health at: ${STAGING_URL}/health"

          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${STAGING_URL}/health" --max-time 30 || echo "000")

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Staging is not healthy (HTTP $HTTP_CODE). Cannot deploy to production."
            echo "Please ensure staging is working before deploying to production."
            exit 1
          fi

          echo "Staging is healthy (HTTP $HTTP_CODE)"

  # ===========================================================================
  # Production Deployment
  # ===========================================================================
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [verify-staging]
    if: always() && (needs.verify-staging.result == 'success' || needs.verify-staging.result == 'skipped')
    timeout-minutes: 30
    environment:
      name: production
      url: ${{ steps.deploy.outputs.service_url }}

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name || inputs.version }}

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }} --quiet

      - name: Determine version tag
        id: version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="${{ github.event.release.tag_name }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Deploying version: ${VERSION}"

      - name: Build Docker image
        run: |
          IMAGE_TAG="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}"
          VERSION="${{ steps.version.outputs.version }}"

          docker build \
            -f Dockerfile.cloudrun \
            -t "${IMAGE_TAG}:${VERSION}" \
            -t "${IMAGE_TAG}:production-latest" \
            -t "${IMAGE_TAG}:${{ github.sha }}" \
            --build-arg APP_ENV=production \
            --cache-from "${IMAGE_TAG}:production-latest" \
            .

      - name: Push Docker image
        run: |
          IMAGE_TAG="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}"
          VERSION="${{ steps.version.outputs.version }}"

          docker push "${IMAGE_TAG}:${VERSION}"
          docker push "${IMAGE_TAG}:production-latest"
          docker push "${IMAGE_TAG}:${{ github.sha }}"

      - name: Deploy to Cloud Run
        id: deploy
        run: |
          IMAGE_TAG="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}"

          # Read configuration files
          ENV_VARS=$(cat cloudrun-env-vars.production.txt | tr '\n' ',')
          SECRETS=$(cat cloudrun-secrets.txt | tr '\n' ',')

          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image="${IMAGE_TAG}" \
            --region=${{ env.REGION }} \
            --platform=managed \
            --port=8090 \
            --memory=4Gi \
            --cpu=2 \
            --min-instances=1 \
            --max-instances=10 \
            --concurrency=80 \
            --timeout=300s \
            --allow-unauthenticated \
            --execution-environment=gen2 \
            --set-env-vars="${ENV_VARS%,}" \
            --set-secrets="${SECRETS%,}" \
            --service-account=olorin-detection@${{ env.PROJECT_ID }}.iam.gserviceaccount.com \
            --quiet

          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --format='value(status.url)')

          echo "service_url=${SERVICE_URL}" >> $GITHUB_OUTPUT

      - name: Verify deployment
        run: |
          SERVICE_URL="${{ steps.deploy.outputs.service_url }}"

          echo "Service URL: $SERVICE_URL"

          # More thorough health check for production
          for i in {1..18}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${SERVICE_URL}/health" || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Health check passed!"

              # Verify docs endpoint too
              DOCS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${SERVICE_URL}/docs" || echo "000")
              if [ "$DOCS_CODE" = "200" ]; then
                echo "Docs endpoint verified!"
                exit 0
              fi
            fi
            echo "Waiting for service... Attempt $i/18 (HTTP $HTTP_CODE)"
            sleep 10
          done

          echo "::error::Health check failed!"
          exit 1

      - name: Tag successful deployment
        run: |
          IMAGE_TAG="${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}"
          VERSION="${{ steps.version.outputs.version }}"

          # Tag as deployed-production
          docker tag "${IMAGE_TAG}:${VERSION}" "${IMAGE_TAG}:deployed-production"
          docker push "${IMAGE_TAG}:deployed-production"

      - name: Post deployment summary
        if: success()
        run: |
          SERVICE_URL="${{ steps.deploy.outputs.service_url }}"
          VERSION="${{ steps.version.outputs.version }}"

          REVISION=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --format='value(status.latestReadyRevisionName)')

          echo "## Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | **Production** |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${VERSION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Revision | \`${REVISION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Service | ${{ env.SERVICE_NAME }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | ${{ env.REGION }} |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | [${SERVICE_URL}](${SERVICE_URL}) |" >> $GITHUB_STEP_SUMMARY
          echo "| Health | [${SERVICE_URL}/health](${SERVICE_URL}/health) |" >> $GITHUB_STEP_SUMMARY
          echo "| Docs | [${SERVICE_URL}/docs](${SERVICE_URL}/docs) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Rollback Command" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "gcloud run services update-traffic ${{ env.SERVICE_NAME }} \\" >> $GITHUB_STEP_SUMMARY
          echo "  --to-revisions=PREVIOUS_REVISION=100 \\" >> $GITHUB_STEP_SUMMARY
          echo "  --region=${{ env.REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Notify on Deployment
  # ===========================================================================
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()

    steps:
      - name: Notify success
        if: needs.deploy.result == 'success'
        run: |
          echo "::notice::Production deployment successful!"

      - name: Notify failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "::error::Production deployment failed!"
          echo "Immediate action may be required."
          echo "Consider rolling back to the previous revision."

      # Uncomment for Slack notifications:
      # - name: Slack Notification
      #   uses: 8398a7/action-slack@v3
      #   with:
      #     status: ${{ needs.deploy.result }}
      #     fields: repo,message,commit,author,action,eventName,ref,workflow
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
