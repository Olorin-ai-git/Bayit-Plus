"""
Search Result Caching Service.

Provides in-memory caching for search results to improve performance
and reduce database load for popular queries.
"""

import hashlib
import json
import logging
import time
from typing import Dict, Any, Optional
from datetime import datetime, timedelta

from app.core.config import settings

logger = logging.getLogger(__name__)


class SearchCacheService:
    """
    Simple in-memory cache for search results.

    Features:
    - TTL-based expiration (default 5 minutes from settings)
    - Automatic cleanup of expired entries
    - Cache key generation from query and filters
    - Thread-safe operations
    """

    def __init__(self):
        self._cache: Dict[str, Dict[str, Any]] = {}
        self._cache_timestamps: Dict[str, float] = {}
        self.default_ttl = settings.SEARCH_CACHE_TTL_SECONDS
        logger.info(f"SearchCacheService initialized with TTL: {self.default_ttl}s")

    def generate_cache_key(self, query: str, filters: Dict[str, Any]) -> str:
        """
        Generate consistent cache key from query and filters.

        Args:
            query: Search query string
            filters: Dictionary of filter parameters

        Returns:
            MD5 hash of query + sorted filters as cache key
        """
        # Create deterministic string from query and filters
        filter_str = json.dumps(filters, sort_keys=True)
        key_data = f"{query}:{filter_str}"

        # Generate MD5 hash for compact key
        hash_obj = hashlib.md5(key_data.encode())
        cache_key = f"search:{hash_obj.hexdigest()}"

        return cache_key

    def get(self, cache_key: str) -> Optional[Dict[str, Any]]:
        """
        Get cached search results if not expired.

        Args:
            cache_key: Cache key generated by generate_cache_key()

        Returns:
            Cached results dict or None if not found/expired
        """
        # Clean up expired entries periodically
        self._cleanup_expired()

        # Check if key exists
        if cache_key not in self._cache:
            logger.debug(f"Cache MISS: {cache_key}")
            return None

        # Check if expired
        timestamp = self._cache_timestamps.get(cache_key, 0)
        age = time.time() - timestamp

        if age > self.default_ttl:
            logger.debug(f"Cache EXPIRED: {cache_key} (age: {age:.1f}s)")
            # Remove expired entry
            del self._cache[cache_key]
            del self._cache_timestamps[cache_key]
            return None

        logger.debug(f"Cache HIT: {cache_key} (age: {age:.1f}s)")
        return self._cache[cache_key]

    def set(self, cache_key: str, results: Dict[str, Any], ttl: Optional[int] = None) -> None:
        """
        Cache search results with TTL.

        Args:
            cache_key: Cache key generated by generate_cache_key()
            results: Search results to cache
            ttl: Optional custom TTL in seconds (uses default if None)
        """
        self._cache[cache_key] = results
        self._cache_timestamps[cache_key] = time.time()

        used_ttl = ttl or self.default_ttl
        logger.debug(f"Cache SET: {cache_key} (TTL: {used_ttl}s, size: {len(results.get('results', []))} items)")

    def get_cached_results(
        self,
        query: str,
        filters: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """
        Get cached results for query and filters.

        Args:
            query: Search query string
            filters: Dictionary of filter parameters

        Returns:
            Cached results or None
        """
        cache_key = self.generate_cache_key(query, filters)
        return self.get(cache_key)

    def cache_results(
        self,
        query: str,
        filters: Dict[str, Any],
        results: Dict[str, Any],
        ttl: Optional[int] = None
    ) -> None:
        """
        Cache search results for query and filters.

        Args:
            query: Search query string
            filters: Dictionary of filter parameters
            results: Search results to cache
            ttl: Optional custom TTL in seconds
        """
        cache_key = self.generate_cache_key(query, filters)
        self.set(cache_key, results, ttl)

    def invalidate(self, query: Optional[str] = None, filters: Optional[Dict[str, Any]] = None) -> None:
        """
        Invalidate specific cache entry or all entries.

        Args:
            query: Optional query to invalidate (if None, clears all)
            filters: Optional filters (required if query is provided)
        """
        if query is None:
            # Clear all cache
            count = len(self._cache)
            self._cache.clear()
            self._cache_timestamps.clear()
            logger.info(f"Cache CLEARED: {count} entries removed")
        else:
            # Clear specific entry
            cache_key = self.generate_cache_key(query, filters or {})
            if cache_key in self._cache:
                del self._cache[cache_key]
                del self._cache_timestamps[cache_key]
                logger.debug(f"Cache INVALIDATED: {cache_key}")

    def _cleanup_expired(self) -> None:
        """
        Remove expired cache entries.
        Called periodically during get() operations.
        """
        now = time.time()
        expired_keys = []

        for key, timestamp in self._cache_timestamps.items():
            age = now - timestamp
            if age > self.default_ttl:
                expired_keys.append(key)

        if expired_keys:
            for key in expired_keys:
                del self._cache[key]
                del self._cache_timestamps[key]
            logger.debug(f"Cache CLEANUP: Removed {len(expired_keys)} expired entries")

    def get_stats(self) -> Dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache stats
        """
        return {
            "total_entries": len(self._cache),
            "default_ttl": self.default_ttl,
            "oldest_entry_age": (
                time.time() - min(self._cache_timestamps.values())
                if self._cache_timestamps else 0
            ),
            "newest_entry_age": (
                time.time() - max(self._cache_timestamps.values())
                if self._cache_timestamps else 0
            ),
        }


# Global cache instance
_cache_instance: Optional[SearchCacheService] = None


def get_cache() -> SearchCacheService:
    """
    Get or create global cache instance.

    Returns:
        SearchCacheService instance
    """
    global _cache_instance
    if _cache_instance is None:
        _cache_instance = SearchCacheService()
    return _cache_instance
