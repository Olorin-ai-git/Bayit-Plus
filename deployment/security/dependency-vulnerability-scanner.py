#!/usr/bin/env python3
"""
Dependency Vulnerability Scanner
Supply chain security analysis for Python and Node.js dependencies
Part of Phase 5: Security & Compliance Automation

Author: Gil Klainert
Date: 2025-09-06
"""

import os
import sys
import json
import subprocess
import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Set
from dataclasses import dataclass
from datetime import datetime
import yaml
import toml
import re

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityDetail:
    """Detailed vulnerability information"""
    cve_id: str
    severity: str
    cvss_score: float
    title: str
    description: str
    references: List[str]
    patched_versions: List[str]
    vulnerable_versions: str

@dataclass
class DependencyVulnerability:
    """Vulnerable dependency information"""
    package_name: str
    current_version: str
    ecosystem: str  # 'python' or 'npm'
    vulnerability: VulnerabilityDetail
    fix_available: bool
    fixed_version: Optional[str]
    direct_dependency: bool

@dataclass
class ScanResult:
    """Dependency vulnerability scan result"""
    project_path: str
    scan_timestamp: datetime
    ecosystems_scanned: List[str]
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    direct_deps_affected: int
    transitive_deps_affected: int
    vulnerabilities: List[DependencyVulnerability]
    scan_duration: float
    status: str

class DependencyVulnerabilityScanner:
    """Multi-ecosystem dependency vulnerability scanner"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or "deployment/security/dependency-config.yaml"
        self.config = self._load_config()
        self.tools_available = self._check_tool_availability()
        
    def _load_config(self) -> Dict:
        """Load scanner configuration"""
        default_config = {
            'python': {
                'enabled': True,
                'tools': ['safety', 'pip-audit'],
                'files': ['pyproject.toml', 'poetry.lock', 'requirements.txt', 'Pipfile.lock'],
                'ignore_ids': [],  # CVE IDs to ignore
                'severity_threshold': 'LOW'
            },
            'nodejs': {
                'enabled': True,
                'tools': ['npm audit', 'yarn audit'],
                'files': ['package.json', 'package-lock.json', 'yarn.lock'],
                'ignore_ids': [],
                'severity_threshold': 'LOW'
            },
            'security_thresholds': {
                'critical': 0,
                'high': 2,
                'medium': 8,
                'total': 15
            },
            'supply_chain': {
                'check_typosquatting': True,
                'check_malicious_packages': True,
                'verify_checksums': True
            }
        }
        
        if os.path.exists(self.config_path):
            try:
                with open(self.config_path, 'r') as f:
                    user_config = yaml.safe_load(f)
                    default_config.update(user_config)
            except Exception as e:
                logger.warning(f"Failed to load config: {e}, using defaults")
                
        return default_config
    
    def _check_tool_availability(self) -> Dict[str, bool]:
        """Check which scanning tools are available"""
        tools = {}
        
        # Check Python tools
        for tool in ['safety', 'pip-audit']:
            try:
                cmd = [tool, '--version'] if tool != 'pip-audit' else ['pip-audit', '--version']
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                tools[tool] = result.returncode == 0
                logger.info(f"{tool} available: {tools[tool]}")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                tools[tool] = False
                logger.warning(f"{tool} not found")
        
        # Check Node.js tools
        for tool in ['npm', 'yarn']:
            try:
                result = subprocess.run([tool, '--version'], 
                                      capture_output=True, text=True, timeout=10)
                tools[tool] = result.returncode == 0
                logger.info(f"{tool} available: {tools[tool]}")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                tools[tool] = False
                logger.warning(f"{tool} not found")
        
        return tools
    
    def scan_project(self, project_path: str) -> ScanResult:
        """Scan project dependencies for vulnerabilities"""
        logger.info(f"Starting dependency vulnerability scan for: {project_path}")
        start_time = datetime.now()
        
        if not os.path.exists(project_path):
            return self._create_error_result(project_path, "Project path does not exist")
        
        all_vulnerabilities = []
        ecosystems_scanned = []
        
        try:
            # Scan Python dependencies
            if self.config['python']['enabled'] and self._has_python_deps(project_path):
                python_vulns = self._scan_python_dependencies(project_path)
                all_vulnerabilities.extend(python_vulns)
                ecosystems_scanned.append('python')
            
            # Scan Node.js dependencies
            if self.config['nodejs']['enabled'] and self._has_nodejs_deps(project_path):
                nodejs_vulns = self._scan_nodejs_dependencies(project_path)
                all_vulnerabilities.extend(nodejs_vulns)
                ecosystems_scanned.append('nodejs')
            
            # Calculate metrics
            severity_counts = self._calculate_severity_counts(all_vulnerabilities)
            direct_count = len([v for v in all_vulnerabilities if v.direct_dependency])
            transitive_count = len([v for v in all_vulnerabilities if not v.direct_dependency])
            
            duration = (datetime.now() - start_time).total_seconds()
            
            result = ScanResult(
                project_path=project_path,
                scan_timestamp=start_time,
                ecosystems_scanned=ecosystems_scanned,
                total_vulnerabilities=len(all_vulnerabilities),
                critical_count=severity_counts.get('CRITICAL', 0),
                high_count=severity_counts.get('HIGH', 0),
                medium_count=severity_counts.get('MEDIUM', 0),
                low_count=severity_counts.get('LOW', 0),
                direct_deps_affected=direct_count,
                transitive_deps_affected=transitive_count,
                vulnerabilities=sorted(all_vulnerabilities, 
                                     key=lambda x: (self._severity_weight(x.vulnerability.severity), 
                                                  x.vulnerability.cvss_score), 
                                     reverse=True),
                scan_duration=duration,
                status='completed'
            )
            
            logger.info(f"Scan completed in {duration:.2f}s - Found {len(all_vulnerabilities)} vulnerabilities")
            return result
            
        except Exception as e:
            logger.error(f"Dependency scan failed: {str(e)}")
            return self._create_error_result(project_path, str(e))
    
    def _has_python_deps(self, project_path: str) -> bool:
        """Check if project has Python dependencies"""
        python_files = self.config['python']['files']
        return any(os.path.exists(os.path.join(project_path, f)) for f in python_files)
    
    def _has_nodejs_deps(self, project_path: str) -> bool:
        """Check if project has Node.js dependencies"""
        nodejs_files = self.config['nodejs']['files']
        return any(os.path.exists(os.path.join(project_path, f)) for f in nodejs_files)
    
    def _scan_python_dependencies(self, project_path: str) -> List[DependencyVulnerability]:
        """Scan Python dependencies using Safety and pip-audit"""
        vulnerabilities = []
        
        # Try Safety first
        if self.tools_available.get('safety'):
            try:
                safety_vulns = self._run_safety_scan(project_path)
                vulnerabilities.extend(safety_vulns)
            except Exception as e:
                logger.warning(f"Safety scan failed: {e}")
        
        # Try pip-audit as backup/supplement
        if self.tools_available.get('pip-audit'):
            try:
                pip_audit_vulns = self._run_pip_audit_scan(project_path)
                # Deduplicate with Safety results
                existing_cves = {v.vulnerability.cve_id for v in vulnerabilities}
                new_vulns = [v for v in pip_audit_vulns if v.vulnerability.cve_id not in existing_cves]
                vulnerabilities.extend(new_vulns)
            except Exception as e:
                logger.warning(f"pip-audit scan failed: {e}")
        
        return vulnerabilities
    
    def _run_safety_scan(self, project_path: str) -> List[DependencyVulnerability]:
        """Run Safety vulnerability scan"""
        vulnerabilities = []
        
        cmd = [
            'safety', 'check',
            '--json',
            '--output', 'screen'
        ]
        
        # Change to project directory for Safety to find requirements
        original_cwd = os.getcwd()
        try:
            os.chdir(project_path)
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if result.stdout:
                try:
                    safety_data = json.loads(result.stdout)
                    
                    for vuln_data in safety_data:
                        vulnerability_detail = VulnerabilityDetail(
                            cve_id=vuln_data.get('id', 'UNKNOWN'),
                            severity=self._map_safety_severity(vuln_data.get('id', '')),
                            cvss_score=0.0,  # Safety doesn't provide CVSS scores
                            title=vuln_data.get('advisory', ''),
                            description=vuln_data.get('advisory', ''),
                            references=[],
                            patched_versions=vuln_data.get('specs', []),
                            vulnerable_versions=vuln_data.get('v', 'unknown')
                        )
                        
                        dep_vulnerability = DependencyVulnerability(
                            package_name=vuln_data.get('package_name', 'unknown'),
                            current_version=vuln_data.get('installed_version', 'unknown'),
                            ecosystem='python',
                            vulnerability=vulnerability_detail,
                            fix_available=len(vuln_data.get('specs', [])) > 0,
                            fixed_version=vuln_data.get('specs', [None])[0],
                            direct_dependency=True  # Safety shows direct deps
                        )
                        
                        vulnerabilities.append(dep_vulnerability)
                        
                except json.JSONDecodeError:
                    logger.warning("Failed to parse Safety JSON output")
                    
        finally:
            os.chdir(original_cwd)
        
        return vulnerabilities
    
    def _run_pip_audit_scan(self, project_path: str) -> List[DependencyVulnerability]:
        """Run pip-audit vulnerability scan"""
        vulnerabilities = []
        
        cmd = [
            'pip-audit',
            '--format', 'json',
            '--desc'
        ]
        
        original_cwd = os.getcwd()
        try:
            os.chdir(project_path)
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if result.stdout:
                try:
                    audit_data = json.loads(result.stdout)
                    
                    for vuln_entry in audit_data.get('vulnerabilities', []):
                        vulnerability_detail = VulnerabilityDetail(
                            cve_id=vuln_entry.get('id', 'UNKNOWN'),
                            severity='MEDIUM',  # pip-audit doesn't provide severity
                            cvss_score=0.0,
                            title=vuln_entry.get('description', ''),
                            description=vuln_entry.get('description', ''),
                            references=[vuln_entry.get('fix', {}).get('versions', [])],
                            patched_versions=vuln_entry.get('fix', {}).get('versions', []),
                            vulnerable_versions=vuln_entry.get('package', {}).get('version', 'unknown')
                        )
                        
                        dep_vulnerability = DependencyVulnerability(
                            package_name=vuln_entry.get('package', {}).get('name', 'unknown'),
                            current_version=vuln_entry.get('package', {}).get('version', 'unknown'),
                            ecosystem='python',
                            vulnerability=vulnerability_detail,
                            fix_available=len(vuln_entry.get('fix', {}).get('versions', [])) > 0,
                            fixed_version=vuln_entry.get('fix', {}).get('versions', [None])[0],
                            direct_dependency=True
                        )
                        
                        vulnerabilities.append(dep_vulnerability)
                        
                except json.JSONDecodeError:
                    logger.warning("Failed to parse pip-audit JSON output")
                    
        finally:
            os.chdir(original_cwd)
        
        return vulnerabilities
    
    def _scan_nodejs_dependencies(self, project_path: str) -> List[DependencyVulnerability]:
        """Scan Node.js dependencies using npm audit or yarn audit"""
        vulnerabilities = []
        
        # Try npm audit first
        if self.tools_available.get('npm') and os.path.exists(os.path.join(project_path, 'package.json')):
            try:
                npm_vulns = self._run_npm_audit(project_path)
                vulnerabilities.extend(npm_vulns)
            except Exception as e:
                logger.warning(f"npm audit failed: {e}")
        
        # Try yarn audit if yarn.lock exists
        elif self.tools_available.get('yarn') and os.path.exists(os.path.join(project_path, 'yarn.lock')):
            try:
                yarn_vulns = self._run_yarn_audit(project_path)
                vulnerabilities.extend(yarn_vulns)
            except Exception as e:
                logger.warning(f"yarn audit failed: {e}")
        
        return vulnerabilities
    
    def _run_npm_audit(self, project_path: str) -> List[DependencyVulnerability]:
        """Run npm audit vulnerability scan"""
        vulnerabilities = []
        
        cmd = ['npm', 'audit', '--json']
        
        original_cwd = os.getcwd()
        try:
            os.chdir(project_path)
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)
            
            if result.stdout:
                try:
                    audit_data = json.loads(result.stdout)
                    
                    for vuln_id, vuln_data in audit_data.get('vulnerabilities', {}).items():
                        vulnerability_detail = VulnerabilityDetail(
                            cve_id=vuln_data.get('cves', ['UNKNOWN'])[0] if vuln_data.get('cves') else 'UNKNOWN',
                            severity=vuln_data.get('severity', 'UNKNOWN').upper(),
                            cvss_score=vuln_data.get('cvss', {}).get('score', 0.0),
                            title=vuln_data.get('title', ''),
                            description=vuln_data.get('overview', ''),
                            references=vuln_data.get('references', []),
                            patched_versions=vuln_data.get('patched_versions', []),
                            vulnerable_versions=vuln_data.get('vulnerable_versions', 'unknown')
                        )
                        
                        dep_vulnerability = DependencyVulnerability(
                            package_name=vuln_data.get('name', 'unknown'),
                            current_version=vuln_data.get('via', [{}])[0].get('versions', 'unknown'),
                            ecosystem='nodejs',
                            vulnerability=vulnerability_detail,
                            fix_available=len(vuln_data.get('fixAvailable', {})) > 0,
                            fixed_version=vuln_data.get('fixAvailable', {}).get('version'),
                            direct_dependency=vuln_data.get('isDirect', False)
                        )
                        
                        vulnerabilities.append(dep_vulnerability)
                        
                except json.JSONDecodeError:
                    logger.warning("Failed to parse npm audit JSON output")
                    
        finally:
            os.chdir(original_cwd)
        
        return vulnerabilities
    
    def _run_yarn_audit(self, project_path: str) -> List[DependencyVulnerability]:
        """Run yarn audit vulnerability scan"""
        vulnerabilities = []
        
        cmd = ['yarn', 'audit', '--json']
        
        original_cwd = os.getcwd()
        try:
            os.chdir(project_path)
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)
            
            if result.stdout:
                # Yarn audit outputs line-delimited JSON
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        try:
                            audit_entry = json.loads(line)
                            if audit_entry.get('type') == 'auditAdvisory':
                                data = audit_entry.get('data', {})
                                advisory = data.get('advisory', {})
                                
                                vulnerability_detail = VulnerabilityDetail(
                                    cve_id=advisory.get('cves', ['UNKNOWN'])[0] if advisory.get('cves') else 'UNKNOWN',
                                    severity=advisory.get('severity', 'UNKNOWN').upper(),
                                    cvss_score=advisory.get('cvss', 0.0),
                                    title=advisory.get('title', ''),
                                    description=advisory.get('overview', ''),
                                    references=advisory.get('references', []),
                                    patched_versions=advisory.get('patched_versions', []),
                                    vulnerable_versions=advisory.get('vulnerable_versions', 'unknown')
                                )
                                
                                dep_vulnerability = DependencyVulnerability(
                                    package_name=advisory.get('module_name', 'unknown'),
                                    current_version=data.get('resolution', {}).get('version', 'unknown'),
                                    ecosystem='nodejs',
                                    vulnerability=vulnerability_detail,
                                    fix_available=len(advisory.get('patched_versions', [])) > 0,
                                    fixed_version=advisory.get('patched_versions', [None])[0],
                                    direct_dependency=True  # Yarn doesn't distinguish clearly
                                )
                                
                                vulnerabilities.append(dep_vulnerability)
                                
                        except json.JSONDecodeError:
                            continue  # Skip malformed lines
                            
        finally:
            os.chdir(original_cwd)
        
        return vulnerabilities
    
    def _map_safety_severity(self, advisory_id: str) -> str:
        """Map Safety advisory ID to severity (heuristic-based)"""
        # Safety doesn't provide severity, so we use heuristics
        if 'critical' in advisory_id.lower() or 'rce' in advisory_id.lower():
            return 'CRITICAL'
        elif 'high' in advisory_id.lower() or 'injection' in advisory_id.lower():
            return 'HIGH'
        else:
            return 'MEDIUM'
    
    def _calculate_severity_counts(self, vulnerabilities: List[DependencyVulnerability]) -> Dict[str, int]:
        """Calculate counts by severity"""
        counts = {}
        for vuln in vulnerabilities:
            severity = vuln.vulnerability.severity
            counts[severity] = counts.get(severity, 0) + 1
        return counts
    
    def _severity_weight(self, severity: str) -> int:
        """Get severity weight for sorting"""
        weights = {'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1}
        return weights.get(severity, 0)
    
    def _create_error_result(self, project_path: str, error_msg: str) -> ScanResult:
        """Create error scan result"""
        return ScanResult(
            project_path=project_path,
            scan_timestamp=datetime.now(),
            ecosystems_scanned=[],
            total_vulnerabilities=0,
            critical_count=0,
            high_count=0,
            medium_count=0,
            low_count=0,
            direct_deps_affected=0,
            transitive_deps_affected=0,
            vulnerabilities=[],
            scan_duration=0.0,
            status=f'error: {error_msg}'
        )
    
    def evaluate_security_gate(self, result: ScanResult) -> Tuple[bool, str]:
        """Evaluate if dependencies pass security gate"""
        thresholds = self.config['security_thresholds']
        
        if result.status.startswith('error'):
            return False, f"Scan failed: {result.status}"
        
        if result.critical_count > thresholds['critical']:
            return False, f"Critical vulnerabilities: {result.critical_count} (max: {thresholds['critical']})"
        
        if result.high_count > thresholds['high']:
            return False, f"High vulnerabilities: {result.high_count} (max: {thresholds['high']})"
            
        if result.medium_count > thresholds['medium']:
            return False, f"Medium vulnerabilities: {result.medium_count} (max: {thresholds['medium']})"
            
        if result.total_vulnerabilities > thresholds['total']:
            return False, f"Total vulnerabilities: {result.total_vulnerabilities} (max: {thresholds['total']})"
        
        return True, "Security gate passed"
    
    def generate_report(self, result: ScanResult, output_path: str) -> None:
        """Generate dependency vulnerability report"""
        report = {
            'scan_summary': {
                'project_path': result.project_path,
                'scan_timestamp': result.scan_timestamp.isoformat(),
                'ecosystems_scanned': result.ecosystems_scanned,
                'total_vulnerabilities': result.total_vulnerabilities,
                'severity_breakdown': {
                    'critical': result.critical_count,
                    'high': result.high_count,
                    'medium': result.medium_count,
                    'low': result.low_count
                },
                'dependency_breakdown': {
                    'direct_dependencies_affected': result.direct_deps_affected,
                    'transitive_dependencies_affected': result.transitive_deps_affected
                },
                'scan_duration': result.scan_duration,
                'status': result.status
            },
            'vulnerabilities': [
                {
                    'package_name': vuln.package_name,
                    'current_version': vuln.current_version,
                    'ecosystem': vuln.ecosystem,
                    'direct_dependency': vuln.direct_dependency,
                    'vulnerability': {
                        'cve_id': vuln.vulnerability.cve_id,
                        'severity': vuln.vulnerability.severity,
                        'cvss_score': vuln.vulnerability.cvss_score,
                        'title': vuln.vulnerability.title,
                        'description': vuln.vulnerability.description[:500] + '...' if len(vuln.vulnerability.description) > 500 else vuln.vulnerability.description
                    },
                    'fix_available': vuln.fix_available,
                    'fixed_version': vuln.fixed_version
                } for vuln in result.vulnerabilities[:75]  # Limit to top 75
            ]
        }
        
        with open(output_path, 'w') as f:
            json.dump(report, f, indent=2)
        
        logger.info(f"Dependency vulnerability report saved to: {output_path}")

def main():
    """Main execution function"""
    if len(sys.argv) < 2:
        print("Usage: dependency-vulnerability-scanner.py <project_path> [output_path]")
        sys.exit(1)
    
    project_path = sys.argv[1]
    output_path = sys.argv[2] if len(sys.argv) > 2 else f"dependency-report-{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    
    # Initialize scanner
    scanner = DependencyVulnerabilityScanner()
    
    # Perform scan
    result = scanner.scan_project(project_path)
    
    # Evaluate security gate
    passed, message = scanner.evaluate_security_gate(result)
    
    # Generate report
    scanner.generate_report(result, output_path)
    
    # Print summary
    print(f"\n=== Dependency Vulnerability Scan Results ===")
    print(f"Project: {project_path}")
    print(f"Ecosystems: {', '.join(result.ecosystems_scanned)}")
    print(f"Total Vulnerabilities: {result.total_vulnerabilities}")
    print(f"Critical: {result.critical_count}, High: {result.high_count}, Medium: {result.medium_count}, Low: {result.low_count}")
    print(f"Direct Dependencies Affected: {result.direct_deps_affected}")
    print(f"Transitive Dependencies Affected: {result.transitive_deps_affected}")
    print(f"Security Gate: {'PASSED' if passed else 'FAILED'}")
    print(f"Message: {message}")
    print(f"Report: {output_path}")
    
    # Exit with appropriate code
    sys.exit(0 if passed else 1)

if __name__ == "__main__":
    main()