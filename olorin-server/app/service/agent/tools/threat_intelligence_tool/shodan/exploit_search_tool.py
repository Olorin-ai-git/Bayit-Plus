"""Shodan Exploit Search Tool for vulnerability and exploit intelligence."""

import json
from datetime import datetime
from typing import Any, Dict, List, Optional

from langchain.tools import BaseTool
from pydantic import BaseModel, Field

from .models import ShodanExploitResult
from .shodan_client import ShodanClient
from app.service.logging import get_bridge_logger


logger = get_bridge_logger(__name__)


class ExploitSearchInput(BaseModel):
    """Input schema for exploit search."""
    
    query: str = Field(
        ...,
        description="Search query for exploits (CVE, product name, or description)"
    )
    facets: Optional[str] = Field(
        None,
        description="Comma-separated facets (e.g., 'author,platform,type')"
    )
    
    
class ShodanExploitSearchTool(BaseTool):
    """Shodan exploit search tool for vulnerability intelligence."""
    
    name: str = "shodan_exploit_search"
    description: str = (
        "Search for exploits and vulnerabilities using Shodan's exploit database. "
        "Find CVEs, proof-of-concepts, and vulnerability information. "
        "Useful for understanding attack vectors, identifying vulnerable systems, "
        "and investigating potential security threats in fraud cases."
    )
    args_schema: type = ExploitSearchInput
    
    def __init__(self):
        """Initialize the exploit search tool."""
        super().__init__()
        self._client: Optional[ShodanClient] = None
    
    @property
    def client(self) -> ShodanClient:
        """Get or create Shodan client instance."""
        if self._client is None:
            self._client = ShodanClient()
        return self._client
    
    def _run(self, **kwargs) -> str:
        """Execute search synchronously."""
        import asyncio
        return asyncio.run(self._arun(**kwargs))
    
    async def _arun(
        self,
        query: str,
        facets: Optional[str] = None,
        **kwargs
    ) -> str:
        """Execute exploit search asynchronously."""
        try:
            # Search for exploits
            exploits = await self.client.search_exploits(
                query=query,
                facets=facets,
                page=1
            )
            
            # Build comprehensive analysis
            analysis_result = await self._build_exploit_analysis(
                exploits=exploits,
                query=query
            )
            
            return json.dumps(analysis_result, indent=2, default=str)
            
        except Exception as e:
            error_msg = f"Shodan exploit search failed for '{query}': {str(e)}"
            logger.error(error_msg, exc_info=True)
            return json.dumps({
                "error": error_msg,
                "query": query,
                "source": "Shodan"
            }, indent=2)
    
    async def _build_exploit_analysis(
        self,
        exploits: List[ShodanExploitResult],
        query: str
    ) -> Dict[str, Any]:
        """Build comprehensive exploit analysis result."""
        
        result = {
            "exploit_analysis": {
                "query": query,
                "total_exploits": len(exploits),
                "analysis_timestamp": datetime.now().isoformat(),
                "source": "Shodan"
            }
        }
        
        if exploits:
            # Categorize exploits
            cve_exploits = []
            recent_exploits = []
            critical_exploits = []
            
            for exploit in exploits[:20]:  # Limit to 20 exploits
                exploit_info = {
                    "cve": exploit.cve,
                    "description": exploit.description[:200],  # Truncate description
                    "author": exploit.author,
                    "type": exploit.type,
                    "platform": exploit.platform,
                    "port": exploit.port,
                    "date": str(exploit.date) if exploit.date else None,
                    "age_days": exploit.age_days
                }
                
                # Categorize
                if exploit.cve:
                    cve_exploits.append(exploit_info)
                
                if exploit.age_days and exploit.age_days < 90:
                    recent_exploits.append(exploit_info)
                
                # Check for critical keywords
                desc_lower = exploit.description.lower()
                if any(keyword in desc_lower for keyword in 
                       ['remote code', 'rce', 'privilege', 'bypass', 'overflow']):
                    critical_exploits.append(exploit_info)
            
            # Add categorized results
            result["exploit_analysis"]["cve_exploits"] = cve_exploits[:10]
            result["exploit_analysis"]["recent_exploits"] = recent_exploits[:5]
            result["exploit_analysis"]["critical_exploits"] = critical_exploits[:5]
            
            # Statistics
            result["exploit_analysis"]["statistics"] = {
                "with_cve": len(cve_exploits),
                "recent_90_days": len(recent_exploits),
                "potentially_critical": len(critical_exploits)
            }
            
            # Platform distribution
            platform_dist = {}
            for exploit in exploits:
                if exploit.platform:
                    platform_dist[exploit.platform] = platform_dist.get(exploit.platform, 0) + 1
            
            result["exploit_analysis"]["platform_distribution"] = dict(
                sorted(platform_dist.items(), key=lambda x: x[1], reverse=True)[:5]
            )
            
            # Type distribution
            type_dist = {}
            for exploit in exploits:
                if exploit.type:
                    type_dist[exploit.type] = type_dist.get(exploit.type, 0) + 1
            
            result["exploit_analysis"]["type_distribution"] = dict(
                sorted(type_dist.items(), key=lambda x: x[1], reverse=True)[:5]
            )
        
        # Risk assessment
        result["risk_assessment"] = self._assess_exploit_risk(exploits)
        
        # Investigation recommendations
        result["investigation_recommendations"] = self._generate_exploit_recommendations(
            exploits, query
        )
        
        return result
    
    def _assess_exploit_risk(self, exploits: List[ShodanExploitResult]) -> Dict[str, Any]:
        """Assess risk based on exploit findings."""
        risk_score = 0
        risk_factors = []
        
        # Recent exploits increase risk
        recent_count = sum(1 for e in exploits if e.age_days and e.age_days < 30)
        if recent_count > 0:
            risk_score += 30
            risk_factors.append(f"{recent_count} exploits published in last 30 days")
        
        # CVE exploits indicate known vulnerabilities
        cve_count = sum(1 for e in exploits if e.cve)
        if cve_count > 5:
            risk_score += 25
            risk_factors.append(f"{cve_count} exploits with CVE identifiers")
        
        # Critical exploit types
        critical_types = ['remote', 'dos', 'shellcode', 'webapps']
        critical_count = sum(1 for e in exploits if e.type and e.type.lower() in critical_types)
        if critical_count > 0:
            risk_score += 20
            risk_factors.append(f"{critical_count} critical exploit types found")
        
        # Determine risk level
        if risk_score >= 60:
            risk_level = "critical"
        elif risk_score >= 40:
            risk_level = "high"
        elif risk_score >= 20:
            risk_level = "medium"
        else:
            risk_level = "low"
        
        return {
            "risk_level": risk_level,
            "risk_score": risk_score,
            "risk_factors": risk_factors[:5]
        }
    
    def _generate_exploit_recommendations(
        self,
        exploits: List[ShodanExploitResult],
        query: str
    ) -> List[str]:
        """Generate investigation recommendations based on exploits."""
        recommendations = []
        
        # CVE-based recommendations
        cve_exploits = [e for e in exploits if e.cve]
        if cve_exploits:
            recommendations.append(
                f"Found {len(cve_exploits)} CVE exploits. Check if target systems are patched."
            )
            recent_cves = [e for e in cve_exploits if e.age_days and e.age_days < 90]
            if recent_cves:
                recommendations.append(
                    "Recent CVEs detected. Priority patching required for affected systems."
                )
        
        # Platform-specific recommendations
        platforms = set(e.platform for e in exploits if e.platform)
        if platforms:
            recommendations.append(
                f"Exploits target platforms: {', '.join(list(platforms)[:3])}. "
                "Verify system inventory and exposure."
            )
        
        # Port-specific recommendations
        ports = set(e.port for e in exploits if e.port)
        if ports:
            recommendations.append(
                f"Exploits target ports: {list(ports)[:5]}. "
                "Check if these services are exposed."
            )
        
        # General recommendations
        recommendations.extend([
            "Cross-reference with vulnerability scanners",
            "Review patch management procedures",
            "Check for indicators of exploitation in logs"
        ])
        
        return recommendations[:7]