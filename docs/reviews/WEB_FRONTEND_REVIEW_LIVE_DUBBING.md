# Web Frontend Expert Review: Live Dubbing Implementation Plan v2.1

**Reviewer**: Web Development Expert (frontend-developer)
**Date**: 2026-01-23
**Plan Version**: 2.1
**Status**: CHANGES REQUIRED

---

## Executive Summary

The Live Dubbing Implementation Plan v2.1 demonstrates strong architectural thinking for the backend and mobile platforms, but **critical web-specific implementation issues must be addressed** before this plan can be approved for web frontend development.

**Critical Issues Identified**: 5
**Security Concerns**: 2
**Architecture Improvements**: 3
**Testing Gaps**: 2

---

## 1. CRITICAL ISSUES

### 1.1 Security: WebSocket Token Exposure (CRITICAL)

**Issue**: Current plan (line 1227-1229) correctly avoids token in URL, but the implementation in `liveDubbingService.ts` (line 149) has a **commented security concern** without implementation guidance.

**Current Plan**:
```typescript
// Build WebSocket URL (no token in URL - protocol-level auth)
const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
const wsHost = API_BASE_URL.replace(/^https?:\/\//, '') || window.location.host;
const wsUrl = `${wsProtocol}//${wsHost}/ws/live/${channelId}/dubbing`;
```

**Current Implementation** (liveDubbingService.ts:149):
```typescript
// SECURITY: Do NOT pass JWT token in URL query parameters (visible in logs, history, referer headers)
// Token is sent securely via first message after WebSocket connection is established
const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
```

**Problem**: The code comment mentions security but doesn't address the fundamental **browser limitation**: WebSocket API in browsers **cannot set custom headers** (unlike Node.js). This means:
- ✅ Token NOT in URL (good)
- ✅ Token sent in first message (good)
- ❌ **Token still logged in browser DevTools → Network → WS tab → Messages tab**
- ❌ Token visible in any browser extension monitoring WebSocket traffic

**Recommended Solution**:
```typescript
// Send auth message with short-lived, single-use session token
// This token should be:
// 1. Generated by backend endpoint: POST /api/v1/live/{channelId}/dubbing/session-token
// 2. Valid for 30 seconds only
// 3. Single-use (invalidated after first WebSocket auth)
// 4. Bound to user session via secure HttpOnly cookie

const sessionTokenResponse = await fetch(
  `${API_BASE_URL}/live/${channelId}/dubbing/session-token`,
  {
    method: 'POST',
    credentials: 'include', // Send HttpOnly session cookie
    headers: {
      'Authorization': `Bearer ${this.jwtToken}`,
      'Content-Type': 'application/json'
    }
  }
);

const { session_token } = await sessionTokenResponse.json();

// Now send session token (not JWT) in WebSocket message
this.ws?.send(JSON.stringify({
  type: 'auth',
  session_token: session_token, // Short-lived, single-use
  timestamp: Date.now(),
  target_lang: targetLanguage,
  voice_id: voiceId,
}));
```

**Backend Change Required**:
```python
# backend/app/api/routes/live_dubbing.py - NEW ENDPOINT

@router.post("/live/{channel_id}/dubbing/session-token")
async def create_dubbing_session_token(
    channel_id: str,
    user: User = Depends(get_current_user)
):
    """
    Generate short-lived, single-use WebSocket session token.
    Prevents JWT exposure in browser WebSocket logs.
    """
    session_token = secrets.token_urlsafe(32)

    # Store in Redis with 30 second TTL
    await redis_client.setex(
        f"dubbing_session_token:{session_token}",
        30,  # 30 seconds
        json.dumps({
            "user_id": str(user.id),
            "channel_id": channel_id,
            "created_at": datetime.now(timezone.utc).isoformat()
        })
    )

    return {"session_token": session_token}
```

**Severity**: HIGH - JWT exposure in browser logs is a security risk
**Required**: YES - Must be fixed before production

---

### 1.2 AudioWorklet HTTPS Requirement (CRITICAL)

**Issue**: Plan mentions AudioWorklet (line 940) but doesn't address **strict HTTPS requirement** for AudioWorklet in browsers.

**Browser Requirement**:
```javascript
// AudioWorkletNode is only available in secure contexts
if (typeof AudioWorkletNode === 'undefined') {
  // This happens on:
  // 1. HTTP (non-localhost)
  // 2. file:// protocol
  // 3. Browsers without AudioWorklet support
}
```

**Problem for Development**:
- ✅ `localhost` works (Chrome/Firefox treat localhost as secure context)
- ❌ Local network IP addresses (e.g., `192.168.1.100:3000`) **DO NOT work**
- ❌ Testing on mobile device via local IP **FAILS**

**Current Plan** (line 940):
```typescript
const audioWorklet = typeof AudioWorkletNode !== 'undefined';
```

**Missing Implementation**: Fallback for non-AudioWorklet environments.

**Recommended Solution**:
```typescript
// web/src/services/dubbingBrowserDetection.ts

export interface BrowserCapabilities {
  captureStream: boolean;
  webAudio: boolean;
  webSocket: boolean;
  audioWorklet: boolean;
  isSecureContext: boolean; // NEW
  supported: boolean;
  unsupportedReason?: string;
  fallbackMode?: 'mediarecorder' | 'scriptprocessor'; // NEW
}

export function detectBrowserCapabilities(): BrowserCapabilities {
  const video = document.createElement('video');
  const captureStream = typeof video.captureStream === 'function' ||
                        typeof (video as any).mozCaptureStream === 'function';
  const webAudio = typeof AudioContext !== 'undefined' ||
                   typeof (window as any).webkitAudioContext !== 'undefined';
  const webSocket = typeof WebSocket !== 'undefined';
  const audioWorklet = typeof AudioWorkletNode !== 'undefined';
  const isSecureContext = window.isSecureContext ||
                         window.location.protocol === 'https:' ||
                         window.location.hostname === 'localhost';

  let supported = captureStream && webAudio && webSocket;
  let unsupportedReason: string | undefined;
  let fallbackMode: 'mediarecorder' | 'scriptprocessor' | undefined;

  // AudioWorklet preferred, but not required
  if (!audioWorklet) {
    if (!isSecureContext) {
      console.warn('[Dubbing] AudioWorklet unavailable: Not a secure context. Using MediaRecorder fallback.');
      fallbackMode = 'mediarecorder';
    } else {
      console.warn('[Dubbing] AudioWorklet unavailable: Browser does not support AudioWorkletNode. Using ScriptProcessorNode fallback.');
      fallbackMode = 'scriptprocessor'; // Deprecated but works
    }
  }

  if (!captureStream) {
    supported = false;
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    if (isSafari || isIOS) {
      unsupportedReason = 'Safari does not support audio capture from video. Please use Chrome, Firefox, or Edge.';
    } else {
      unsupportedReason = 'Your browser does not support audio capture.';
    }
  }

  return {
    captureStream,
    webAudio,
    webSocket,
    audioWorklet,
    isSecureContext,
    supported,
    unsupportedReason,
    fallbackMode,
  };
}
```

**Fallback Implementation**: MediaRecorder API (works on HTTP)
```typescript
// web/src/services/audio/dubbing-capture-mediarecorder.ts

export class MediaRecorderCapture {
  private mediaRecorder: MediaRecorder | null = null;
  private audioContext: AudioContext;

  async start(stream: MediaStream, onChunk: (chunk: ArrayBuffer) => void): Promise<void> {
    this.mediaRecorder = new MediaRecorder(stream, {
      mimeType: 'audio/webm;codecs=opus',
      audioBitsPerSecond: 48000
    });

    this.mediaRecorder.ondataavailable = async (event) => {
      if (event.data.size > 0) {
        // Decode webm/opus to PCM
        const arrayBuffer = await event.data.arrayBuffer();
        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
        const pcm = this.convertToPCM16(audioBuffer);
        onChunk(pcm.buffer);
      }
    };

    // Request data every 100ms (10 chunks/second)
    this.mediaRecorder.start(100);
  }

  private convertToPCM16(audioBuffer: AudioBuffer): Int16Array {
    const samples = audioBuffer.getChannelData(0);
    const pcm = new Int16Array(samples.length);
    for (let i = 0; i < samples.length; i++) {
      const s = Math.max(-1, Math.min(1, samples[i]));
      pcm[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return pcm;
  }
}
```

**Severity**: HIGH - Breaks development on local network
**Required**: YES - Must provide fallback

---

### 1.3 File Size Violation: liveDubbingService.ts (566 lines)

**Issue**: Current implementation file `web/src/services/liveDubbingService.ts` is **566 lines**, violating the **strict 200-line limit** enforced by coding standards.

**Plan States** (line 902):
```
| `web/src/services/liveDubbingService.ts` | Create | ~150 | WebSocket client + audio playback |
```

**Reality**: Current file is **566 lines** (378% over limit)

**Required Refactoring** (Phase 3.3):
```
web/src/services/dubbing/
├── AudioContextManager.ts        (~120 lines) - AudioContext, gain nodes, volume control
├── AudioCaptureProcessor.ts      (~130 lines) - AudioWorklet, downsample, chunk handling
├── WebSocketClient.ts            (~150 lines) - WebSocket connection, auth, reconnection
├── AudioPlaybackMixer.ts         (~130 lines) - Dubbed audio playback, buffer management
├── LiveDubbingService.ts         (~150 lines) - Main orchestration, public API
└── index.ts                      (~10 lines)  - Barrel exports
```

**Split Details**:

**AudioContextManager.ts** (120 lines):
- Create/destroy AudioContext
- Manage gain nodes (original, dubbed)
- Volume control with smooth transitions
- Audio level monitoring (analyser node)

**AudioCaptureProcessor.ts** (130 lines):
- AudioWorklet module registration
- Message handling from worklet
- Downsampling (Lanczos filter)
- Chunk validation and sending

**WebSocketClient.ts** (150 lines):
- WebSocket connection lifecycle
- Protocol-level authentication
- Message parsing and routing
- Reconnection with exponential backoff

**AudioPlaybackMixer.ts** (130 lines):
- Base64 to PCM decoding
- AudioBuffer creation
- Playback scheduling
- Sync delay management

**LiveDubbingService.ts** (150 lines):
- Public API (connect, disconnect, setVolume)
- State management
- Callbacks orchestration
- Browser capability checks

**Severity**: HIGH - Violates mandatory coding standards
**Required**: YES - Must split before merge

---

### 1.4 DubbingControls.tsx: Pressable → GlassButton Conversion

**Issue**: Current implementation uses deprecated `Pressable` for language selection buttons (line 93-111 in DubbingControls.tsx), violating Glass Component Library requirements.

**Current Code** (DubbingControls.tsx:93-111):
```tsx
{availableLanguages.map((lang) => (
  <Pressable
    key={lang}
    onPress={() => onLanguageChange(lang)}
    style={({ hovered }) => [
      styles.langButton,
      targetLanguage === lang && styles.langButtonActive,
      hovered && styles.langButtonHovered,
    ]}
  >
    <Text style={[styles.langText, targetLanguage === lang && styles.langTextActive]}>
      {LANGUAGE_NAMES[lang] || lang.toUpperCase()}
    </Text>
  </Pressable>
))}
```

**Required Change**:
```tsx
// Replace Pressable with GlassButton
import { GlassButton, GlassCard, GlassSelect, GlassBadge, GlassTooltip } from '@bayit/glass';

{availableLanguages.map((lang) => (
  <GlassButton
    key={lang}
    variant={targetLanguage === lang ? 'primary' : 'ghost'}
    size="sm"
    onPress={() => onLanguageChange(lang)}
    accessibilityLabel={`Select ${LANGUAGE_NAMES[lang] || lang} for dubbing`}
  >
    {LANGUAGE_NAMES[lang] || lang.toUpperCase()}
  </GlassButton>
))}
```

**Styling Change**:
```typescript
// REMOVE these styles (handled by GlassButton):
// - langButton
// - langButtonActive
// - langButtonHovered
// - langText
// - langTextActive

// KEEP container styles only
const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.sm,
    position: 'relative',
  },
  languageSelector: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.xs,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xs,
  },
  // Remove langButton, langText, etc.
});
```

**Severity**: MEDIUM - Violates Glass Component requirement
**Required**: YES - Must use Glass components

---

### 1.5 Hardcoded Colors in Existing Implementation

**Issue**: Current implementation has **hardcoded color values** that should come from theme configuration.

**Violations Found**:

**DubbingControls.tsx**:
```typescript
// Line 146: Hardcoded color
backgroundColor: 'rgba(0, 0, 0, 0.5)',
borderColor: 'rgba(168, 85, 247, 0.2)', // Purple-500 with opacity

// Line 156: Hardcoded color
backgroundColor: 'rgba(168, 85, 247, 0.3)', // Purple-500

// Line 159: Hardcoded color
backgroundColor: 'rgba(168, 85, 247, 0.15)',

// Line 173: Hardcoded color
backgroundColor: 'rgba(59, 130, 246, 0.15)', // Blue-500
borderColor: 'rgba(59, 130, 246, 0.3)',

// Line 178: Hardcoded color
color: '#93c5fd', // Blue-300

// Line 187: Hardcoded color
backgroundColor: 'rgba(220, 38, 38, 0.95)', // Red-600
borderColor: 'rgba(248, 113, 113, 0.3)', // Red-400
```

**Required Change**:
```typescript
// Import theme colors
import { colors, spacing, borderRadius } from '@bayit/shared/theme'

const styles = StyleSheet.create({
  languageSelector: {
    backgroundColor: colors.backgroundSecondary, // From theme
    borderColor: colors.border,
    // ...
  },
  langButtonActive: {
    backgroundColor: colors.primaryTransparent, // From theme
  },
  langButtonHovered: {
    backgroundColor: colors.primaryHover,
  },
  latencyBadge: {
    backgroundColor: colors.infoTransparent,
    borderColor: colors.infoBorder,
  },
  latencyText: {
    color: colors.infoText,
  },
  errorContainer: {
    backgroundColor: colors.errorBackground,
    borderColor: colors.errorBorder,
  },
});
```

**Add to Theme** (if missing):
```typescript
// shared/theme/colors.ts

export const colors = {
  // Existing colors...
  primary: '#A855F7', // Purple-500
  primaryTransparent: 'rgba(168, 85, 247, 0.3)',
  primaryHover: 'rgba(168, 85, 247, 0.15)',
  backgroundSecondary: 'rgba(0, 0, 0, 0.5)',
  border: 'rgba(168, 85, 247, 0.2)',
  infoTransparent: 'rgba(59, 130, 246, 0.15)',
  infoBorder: 'rgba(59, 130, 246, 0.3)',
  infoText: '#93c5fd',
  errorBackground: 'rgba(220, 38, 38, 0.95)',
  errorBorder: 'rgba(248, 113, 113, 0.3)',
  // ...
};
```

**Severity**: MEDIUM - Violates no-hardcoded-values rule
**Required**: YES - Must use theme configuration

---

## 2. ARCHITECTURE IMPROVEMENTS

### 2.1 Missing Error Boundary for WebSocket Failures

**Issue**: Plan doesn't specify error boundary component for graceful degradation when dubbing fails.

**Recommendation**:
```tsx
// web/src/components/player/dubbing/DubbingErrorBoundary.tsx

import React, { Component, ReactNode } from 'react';
import { View, Text } from 'react-native';
import { GlassCard, GlassButton } from '@bayit/glass';
import { useTranslation } from 'react-i18next';

interface Props {
  children: ReactNode;
  onReset: () => void;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class DubbingErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('[DubbingErrorBoundary]', error, errorInfo);
    // Log to Sentry/monitoring
  }

  render() {
    if (this.state.hasError) {
      return (
        <GlassCard>
          <Text style={{ color: 'white', fontSize: 16, marginBottom: 12 }}>
            Live dubbing encountered an error
          </Text>
          <Text style={{ color: '#ccc', fontSize: 14, marginBottom: 16 }}>
            {this.state.error?.message || 'Unknown error'}
          </Text>
          <GlassButton
            variant="secondary"
            onPress={() => {
              this.setState({ hasError: false, error: null });
              this.props.onReset();
            }}
          >
            Try Again
          </GlassButton>
        </GlassCard>
      );
    }

    return this.props.children;
  }
}
```

**Usage**:
```tsx
<DubbingErrorBoundary onReset={() => dubbingService.disconnect()}>
  <DubbingControls {...props} />
</DubbingErrorBoundary>
```

**Severity**: LOW - Nice-to-have for production robustness
**Required**: NO (recommended)

---

### 2.2 Performance: Audio Buffer Memory Management

**Issue**: Plan doesn't address **memory leak risk** from audio buffer accumulation during long sessions.

**Current Risk**:
- User watches 2-hour live stream with dubbing enabled
- Dubbed audio chunks accumulate in memory
- Each chunk creates new AudioBuffer (never garbage collected if referenced)
- Potential memory leak: **~50MB/hour** for 48kHz PCM

**Recommendation**:
```typescript
// web/src/services/dubbing/AudioPlaybackMixer.ts

export class AudioPlaybackMixer {
  private activeBuffers: Set<AudioBufferSourceNode> = new Set();
  private bufferCleanupInterval: NodeJS.Timeout | null = null;

  async initialize(audioContext: AudioContext, dubbedGain: GainNode): Promise<void> {
    // ... existing init code

    // Cleanup completed buffers every 5 seconds
    this.bufferCleanupInterval = setInterval(() => {
      this.cleanupCompletedBuffers();
    }, 5000);
  }

  async playDubbedAudio(pcmData: ArrayBuffer): Promise<void> {
    // ... existing playback code

    const source = this.audioContext.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(this.dubbedGain);

    // Track active buffer
    this.activeBuffers.add(source);

    // Remove when playback completes
    source.onended = () => {
      source.disconnect();
      this.activeBuffers.delete(source);
    };

    source.start();
  }

  private cleanupCompletedBuffers(): void {
    const completedBuffers: AudioBufferSourceNode[] = [];

    this.activeBuffers.forEach(buffer => {
      // Remove buffers that have already played
      if (buffer.context.state === 'running') {
        // Buffer still playing
      } else {
        completedBuffers.push(buffer);
      }
    });

    completedBuffers.forEach(buffer => {
      buffer.disconnect();
      this.activeBuffers.delete(buffer);
    });

    if (completedBuffers.length > 0) {
      console.log(`[AudioPlaybackMixer] Cleaned up ${completedBuffers.length} completed buffers`);
    }
  }

  destroy(): void {
    if (this.bufferCleanupInterval) {
      clearInterval(this.bufferCleanupInterval);
      this.bufferCleanupInterval = null;
    }

    // Disconnect all active buffers
    this.activeBuffers.forEach(buffer => buffer.disconnect());
    this.activeBuffers.clear();

    // ... existing destroy code
  }
}
```

**Severity**: MEDIUM - Important for long sessions
**Required**: YES - Add to Phase 3 implementation

---

### 2.3 Missing Consent/Permissions Flow

**Issue**: Plan mentions "DubbingInfoModal" but doesn't specify **explicit user consent** for audio capture, which is required for GDPR/privacy compliance.

**Recommendation**:
```tsx
// web/src/components/player/dubbing/DubbingConsentDialog.tsx

import React from 'react';
import { View, Text } from 'react-native';
import { GlassModal, GlassButton, GlassCheckbox } from '@bayit/glass';
import { useTranslation } from 'react-i18next';

interface DubbingConsentDialogProps {
  visible: boolean;
  onAccept: () => void;
  onDecline: () => void;
}

export function DubbingConsentDialog({ visible, onAccept, onDecline }: DubbingConsentDialogProps) {
  const { t } = useTranslation();
  const [privacyAccepted, setPrivacyAccepted] = React.useState(false);

  return (
    <GlassModal visible={visible} onClose={onDecline}>
      <View style={{ padding: 24 }}>
        <Text style={{ color: 'white', fontSize: 20, fontWeight: 'bold', marginBottom: 16 }}>
          {t('dubbing.consent.title', 'Live Dubbing Privacy Notice')}
        </Text>

        <Text style={{ color: '#ccc', fontSize: 14, marginBottom: 12 }}>
          {t('dubbing.consent.description',
            'To provide real-time dubbing, we will:\n\n' +
            '• Capture audio from the live stream\n' +
            '• Send audio to our servers for processing\n' +
            '• Use third-party AI services (ElevenLabs) for translation and voice synthesis\n\n' +
            'Audio is processed in real-time and not stored permanently.'
          )}
        </Text>

        <GlassCheckbox
          value={privacyAccepted}
          onValueChange={setPrivacyAccepted}
          label={t('dubbing.consent.checkbox', 'I understand and accept the privacy policy')}
        />

        <View style={{ flexDirection: 'row', gap: 12, marginTop: 24 }}>
          <GlassButton variant="secondary" onPress={onDecline} style={{ flex: 1 }}>
            {t('common.decline', 'Decline')}
          </GlassButton>
          <GlassButton
            variant="primary"
            onPress={onAccept}
            disabled={!privacyAccepted}
            style={{ flex: 1 }}
          >
            {t('common.accept', 'Accept')}
          </GlassButton>
        </View>
      </View>
    </GlassModal>
  );
}
```

**Usage Flow**:
```typescript
// First-time dubbing enable
if (!hasShownConsentDialog) {
  showConsentDialog();
  // Store consent in localStorage: 'dubbing_consent_accepted'
}
```

**Severity**: MEDIUM - Required for GDPR compliance
**Required**: YES - Add consent flow

---

## 3. TESTING GAPS

### 3.1 Missing Playwright Cross-Browser Test Matrix

**Issue**: Plan mentions Playwright testing (line 2202) but doesn't specify **comprehensive test matrix** for web.

**Current Plan** (line 2207-2224):
```typescript
test.describe('Live Dubbing', () => {
  test('shows unsupported message in Safari', async ({ page, browserName }) => {
    test.skip(browserName !== 'webkit', 'Safari-specific test');
    await page.goto('/live/channel-123');
    await expect(page.locator('[data-testid="dubbing-unsupported"]')).toBeVisible();
  });
  // ... 1 more test
});
```

**Missing Coverage**:
1. Multiple browsers (Chrome, Firefox, Safari, Edge)
2. Multiple viewports (320px mobile → 2560px 2K desktop)
3. Keyboard navigation (Tab, Enter, Esc)
4. ARIA attributes validation
5. Performance metrics (Core Web Vitals)
6. Console error monitoring

**Required Test Matrix**:
```typescript
// tests/e2e/live-dubbing.spec.ts

const BROWSERS = ['chromium', 'firefox', 'webkit']; // Safari WebKit engine
const VIEWPORTS = [
  { name: 'mobile-sm', width: 320, height: 568 },      // iPhone SE
  { name: 'mobile-md', width: 375, height: 667 },      // iPhone 8
  { name: 'mobile-lg', width: 430, height: 932 },      // iPhone 15 Pro Max
  { name: 'tablet', width: 768, height: 1024 },        // iPad
  { name: 'desktop', width: 1920, height: 1080 },      // Full HD
  { name: 'desktop-2k', width: 2560, height: 1440 },   // 2K
];

for (const browser of BROWSERS) {
  test.describe(`Live Dubbing - ${browser}`, () => {
    test.use({ browserName: browser });

    for (const viewport of VIEWPORTS) {
      test(`renders correctly on ${viewport.name}`, async ({ page }) => {
        await page.setViewportSize({ width: viewport.width, height: viewport.height });
        await page.goto('/live/channel-123');

        // Screenshot comparison
        await expect(page).toHaveScreenshot(`dubbing-controls-${browser}-${viewport.name}.png`);
      });
    }

    test('keyboard navigation works', async ({ page }) => {
      await page.goto('/live/channel-123');
      await page.keyboard.press('Tab'); // Focus settings button
      await page.keyboard.press('Enter'); // Open settings
      await page.keyboard.press('Tab'); // Focus dubbing tab
      await page.keyboard.press('Enter'); // Switch to dubbing tab
      await page.keyboard.press('Tab'); // Focus toggle
      await page.keyboard.press('Space'); // Toggle dubbing

      await expect(page.locator('[data-testid="dubbing-status"]')).toContainText('Active');
    });

    test('accessibility attributes present', async ({ page }) => {
      await page.goto('/live/channel-123');

      // Check ARIA labels
      const settingsButton = page.locator('[data-testid="settings-button"]');
      await expect(settingsButton).toHaveAttribute('aria-label');

      const dubbingToggle = page.locator('[data-testid="dubbing-toggle"]');
      await expect(dubbingToggle).toHaveAttribute('aria-checked');
      await expect(dubbingToggle).toHaveAttribute('role', 'switch');
    });

    test('no console errors', async ({ page }) => {
      const consoleErrors: string[] = [];
      page.on('console', msg => {
        if (msg.type() === 'error') {
          consoleErrors.push(msg.text());
        }
      });

      await page.goto('/live/channel-123');
      await page.click('[data-testid="settings-button"]');
      await page.click('[data-testid="dubbing-toggle"]');

      expect(consoleErrors).toHaveLength(0);
    });

    test('Core Web Vitals within thresholds', async ({ page }) => {
      await page.goto('/live/channel-123');

      const metrics = await page.evaluate(() => {
        return new Promise(resolve => {
          new PerformanceObserver(list => {
            const entries = list.getEntries();
            const lcp = entries.find(e => e.entryType === 'largest-contentful-paint');
            const fid = entries.find(e => e.entryType === 'first-input');
            const cls = entries.find(e => e.entryType === 'layout-shift');

            resolve({
              lcp: lcp?.startTime || 0,
              fid: fid?.processingStart ? fid.processingStart - fid.startTime : 0,
              cls: cls?.value || 0,
            });
          }).observe({ entryTypes: ['largest-contentful-paint', 'first-input', 'layout-shift'] });
        });
      });

      expect(metrics.lcp).toBeLessThan(2500); // < 2.5s
      expect(metrics.fid).toBeLessThan(100);  // < 100ms
      expect(metrics.cls).toBeLessThan(0.1);  // < 0.1
    });
  });
}
```

**Severity**: HIGH - Insufficient test coverage
**Required**: YES - Comprehensive Playwright tests

---

### 3.2 Missing Performance Benchmarks

**Issue**: No web-specific performance benchmarks defined.

**Required Benchmarks**:
```typescript
// tests/performance/dubbing-performance.spec.ts

test('dubbing initialization < 500ms', async ({ page }) => {
  await page.goto('/live/channel-123');

  const startTime = Date.now();
  await page.click('[data-testid="dubbing-toggle"]');
  await page.waitForSelector('[data-testid="dubbing-status"]:has-text("Active")');
  const endTime = Date.now();

  expect(endTime - startTime).toBeLessThan(500);
});

test('audio chunk processing < 50ms per chunk', async ({ page }) => {
  // Use Performance API to measure audio processing time
  const chunkTimes = await page.evaluate(() => {
    return new Promise(resolve => {
      const times: number[] = [];
      // Hook into liveDubbingService.playDubbedAudio
      window.addEventListener('dubbing-chunk-processed', (e: CustomEvent) => {
        times.push(e.detail.processingTime);
        if (times.length >= 100) {
          resolve(times);
        }
      });
    });
  });

  const avgChunkTime = chunkTimes.reduce((a, b) => a + b, 0) / chunkTimes.length;
  expect(avgChunkTime).toBeLessThan(50);
});

test('memory usage stable over 10 minutes', async ({ page }) => {
  await page.goto('/live/channel-123');
  await page.click('[data-testid="dubbing-toggle"]');

  const initialMemory = await page.evaluate(() => performance.memory.usedJSHeapSize);

  // Wait 10 minutes
  await page.waitForTimeout(600000);

  const finalMemory = await page.evaluate(() => performance.memory.usedJSHeapSize);
  const memoryGrowth = finalMemory - initialMemory;

  // Memory growth should be < 100MB over 10 minutes
  expect(memoryGrowth).toBeLessThan(100 * 1024 * 1024);
});
```

**Severity**: MEDIUM - Important for production validation
**Required**: YES - Add performance tests

---

## 4. COMPLIANCE CHECKLIST

### 4.1 Web Frontend Standards Compliance

| Standard | Status | Notes |
|----------|--------|-------|
| **React 18+** | ✅ PASS | Plan uses React 18 hooks |
| **TypeScript** | ✅ PASS | All files use TypeScript |
| **TailwindCSS Only** | ❌ FAIL | N/A - This is React Native (StyleSheet) |
| **StyleSheet.create()** | ✅ PASS | Used in DubbingControls.tsx |
| **No External CSS** | ✅ PASS | No .css files |
| **No CSS-in-JS** | ✅ PASS | No styled-components |
| **Glass Components** | ⚠️ PARTIAL | Pressable used instead of GlassButton (MUST FIX) |
| **No Native Elements** | ⚠️ PARTIAL | Pressable is React Native (web uses divs) |
| **Theme Configuration** | ❌ FAIL | Hardcoded colors found (MUST FIX) |
| **200-Line Limit** | ❌ FAIL | liveDubbingService.ts is 566 lines (MUST FIX) |
| **Browser APIs** | ✅ PASS | Web Audio API, WebSocket used correctly |
| **Accessibility** | ⚠️ PARTIAL | ARIA labels needed in tests |

**Overall Compliance**: 5/12 PASS, 4/12 PARTIAL, 3/12 FAIL

---

### 4.2 Security Compliance

| Security Requirement | Status | Notes |
|---------------------|--------|-------|
| **wss:// in production** | ✅ PASS | Protocol detection implemented |
| **No token in URL** | ✅ PASS | Token sent in first message |
| **Token not logged** | ❌ FAIL | JWT visible in browser DevTools (MUST FIX) |
| **HTTPS for AudioWorklet** | ⚠️ PARTIAL | Localhost works, but no fallback |
| **CORS configuration** | ❓ NOT SPECIFIED | Must verify CORS for WebSocket |
| **Input validation** | ✅ PASS | Backend validates audio chunks |
| **Rate limiting** | ✅ PASS | Olorin rate limiter integrated |
| **Session binding** | ✅ PASS | Session ID tracked in Redis |
| **Consent flow** | ❌ FAIL | No explicit user consent (MUST ADD) |

**Overall Security**: 5/9 PASS, 1/9 PARTIAL, 2/9 FAIL, 1/9 NOT SPECIFIED

---

## 5. RECOMMENDATIONS SUMMARY

### 5.1 MUST FIX (Before Approval)

1. **Security: Implement session token endpoint** (Section 1.1)
   - Backend: POST /api/v1/live/{channelId}/dubbing/session-token
   - Frontend: Use session token instead of JWT in WebSocket messages
   - Priority: HIGH

2. **AudioWorklet: Add MediaRecorder fallback** (Section 1.2)
   - Detect secure context availability
   - Fallback to MediaRecorder on HTTP (development)
   - Fallback to ScriptProcessorNode on older browsers
   - Priority: HIGH

3. **File splitting: Refactor liveDubbingService.ts** (Section 1.3)
   - Split into 5 files: AudioContextManager, AudioCaptureProcessor, WebSocketClient, AudioPlaybackMixer, LiveDubbingService
   - Each file < 150 lines
   - Priority: HIGH

4. **Components: Replace Pressable with GlassButton** (Section 1.4)
   - Replace language selector buttons
   - Remove custom button styles
   - Use Glass variants (primary, ghost)
   - Priority: MEDIUM

5. **Theme: Remove hardcoded colors** (Section 1.5)
   - Extract all colors to theme configuration
   - Use theme imports consistently
   - Priority: MEDIUM

6. **Consent: Add GDPR consent dialog** (Section 2.3)
   - Implement DubbingConsentDialog component
   - Store consent in localStorage
   - Show before first dubbing session
   - Priority: MEDIUM

7. **Testing: Comprehensive Playwright tests** (Section 3.1)
   - Multi-browser matrix (Chrome, Firefox, Safari, Edge)
   - Multi-viewport testing (320px → 2560px)
   - Keyboard navigation tests
   - ARIA attribute validation
   - Performance metrics (Core Web Vitals)
   - Priority: HIGH

8. **Testing: Performance benchmarks** (Section 3.2)
   - Initialization time < 500ms
   - Chunk processing < 50ms
   - Memory stability over 10 minutes
   - Priority: MEDIUM

---

### 5.2 RECOMMENDED (Nice-to-Have)

1. **Error Boundary** (Section 2.1)
   - Graceful error handling
   - User-friendly error messages
   - Reset functionality

2. **Memory Management** (Section 2.2)
   - Audio buffer cleanup
   - Periodic garbage collection
   - Memory leak prevention

---

## 6. APPROVAL STATUS

**Status**: ❌ **CHANGES REQUIRED**

**Blocking Issues** (Must fix before approval):
1. Security: JWT exposure in browser WebSocket logs
2. AudioWorklet: No fallback for HTTP/non-secure contexts
3. File size: liveDubbingService.ts exceeds 200-line limit (566 lines)
4. Components: Pressable usage violates Glass requirement
5. Theme: Hardcoded colors violate configuration standards
6. Testing: Insufficient Playwright test coverage

**Non-Blocking Issues** (Recommended):
1. Missing error boundary component
2. Memory management for long sessions
3. No explicit GDPR consent flow

---

## 7. NEXT STEPS

1. **Address blocking issues** (items 1-6 from section 5.1)
2. **Re-submit plan for review** after fixes
3. **Schedule implementation** after plan approval

---

## 8. SIGN-OFF

**Reviewer**: Web Development Expert (frontend-developer)
**Date**: 2026-01-23
**Approval**: ❌ **NOT APPROVED** - Changes required

**Signature**: The implementation plan demonstrates strong backend and mobile architecture, but critical web-specific issues must be addressed before proceeding. The security concerns (JWT exposure), development workflow issues (AudioWorklet HTTPS), and coding standard violations (file size, hardcoded values) are blockers for production deployment.

Once these issues are resolved, the plan will provide a solid foundation for implementing real-time live dubbing on the web platform.

---

**Document Version**: 1.0
**Last Updated**: 2026-01-23
