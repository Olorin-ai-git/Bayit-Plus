# Enhanced Firebase Hosting Deployment Pipeline
# Production-ready deployment with validation, testing, and monitoring

name: Deploy to Firebase Hosting on merge

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests (emergency deployment)'
        required: false
        default: 'false'
        type: boolean

env:
  NODE_VERSION: '18'
  CACHE_DEPENDENCY_PATH: 'olorin-fraud/frontend/package-lock.json'
  BUILD_PATH: 'olorin-fraud/frontend/build'
  DEPLOYMENT_ENV: ${{ github.event.inputs.environment || 'production' }}

jobs:
  # Pre-deployment validation and testing
  validate:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    outputs:
      should-deploy: ${{ steps.validation.outputs.should-deploy }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: ${{ env.CACHE_DEPENDENCY_PATH }}

      - name: Install Dependencies
        run: |
          cd olorin-fraud/frontend
          npm ci --prefer-offline --no-audit

      - name: Run Linting
        run: |
          cd olorin-fraud/frontend
          npm run lint

      - name: Check Code Formatting
        run: |
          cd olorin-fraud/frontend
          npm run format:check

      - name: Run Unit Tests
        run: |
          cd olorin-fraud/frontend
          npm run test:ci

      - name: Upload Test Coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./olorin-fraud/frontend/coverage/lcov.info
          fail_ci_if_error: false

      - name: Validate Environment Configuration
        id: validation
        run: |
          cd olorin-fraud/frontend
          node deployment/build-config.js validate
          echo "should-deploy=true" >> $GITHUB_OUTPUT

  # Build application with optimizations
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [validate]
    if: always() && (needs.validate.result == 'success' || needs.validate.result == 'skipped')
    outputs:
      build-version: ${{ steps.build-info.outputs.build-version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: ${{ env.CACHE_DEPENDENCY_PATH }}

      - name: Install Dependencies
        run: |
          cd olorin-fraud/frontend
          npm ci --prefer-offline --no-audit

      - name: Initialize Build Configuration
        run: |
          cd olorin-fraud/frontend
          node deployment/build-config.js init
        env:
          REACT_APP_ENV: ${{ env.DEPLOYMENT_ENV }}
          BUILD_TIME: ${{ github.event.head_commit.timestamp }}
          GITHUB_SHA: ${{ github.sha }}
          # Security: Explicitly disable debug features in production
          NODE_ENV: production
          REACT_APP_DEBUG: false

      - name: Build Application
        run: |
          cd olorin-fraud/frontend
          if [ "${{ env.DEPLOYMENT_ENV }}" = "staging" ]; then
            npm run build:staging
          else
            npm run build:production
          fi
        env:
          CI: true
          GENERATE_SOURCEMAP: false  # Never generate sourcemaps for security
          # Firebase Authentication (Feature: firebase-rbac)
          REACT_APP_AUTH_ENABLE_GOOGLE_SIGNIN: true

      - name: Finalize Build
        id: build-info
        run: |
          cd olorin-fraud/frontend
          node deployment/build-config.js finalize
          BUILD_VERSION=$(jq -r '.buildVersion' build/build-metadata.json)
          echo "build-version=$BUILD_VERSION" >> $GITHUB_OUTPUT

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ env.DEPLOYMENT_ENV }}
          path: ${{ env.BUILD_PATH }}
          retention-days: 30

  # Performance and security testing
  test:
    name: Performance & Security Tests
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ env.DEPLOYMENT_ENV }}
          path: ${{ env.BUILD_PATH }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Start Local Server
        run: |
          cd olorin-fraud/frontend
          npm install -g serve
          serve -s build -l 3000 &
          sleep 5

      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v10
        with:
          configPath: './olorin-fraud/frontend/.lighthouserc.json'
          temporaryPublicStorage: true
          uploadArtifacts: true
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}

      - name: Security Audit
        run: |
          cd olorin-fraud/frontend
          echo "ðŸ” Running comprehensive security audit..."
          
          # Run npm audit with strict level for production
          if [ "${{ env.DEPLOYMENT_ENV }}" = "production" ]; then
            npm audit --audit-level high --production
          else
            npm audit --audit-level moderate
          fi
          
          # Check for exposed secrets in build artifacts
          echo "ðŸ” Scanning build artifacts for potential secrets..."
          if grep -r -E "(api[_-]?key|secret|password|token)" ${{ env.BUILD_PATH }} --exclude-dir=node_modules; then
            echo "::warning::Potential secrets found in build artifacts - please review"
          fi
          
          # Verify sourcemaps are not included
          if find ${{ env.BUILD_PATH }} -name "*.map" | grep -q .; then
            echo "::error::Source maps found in production build - security risk"
            exit 1
          fi
          
          echo "âœ… Security audit completed"

  # Deploy to Firebase Hosting
  deploy:
    name: Deploy to Firebase Hosting
    runs-on: ubuntu-latest
    needs: [build, test]
    if: always() && needs.build.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped')
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.deploy.outputs.url }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ env.DEPLOYMENT_ENV }}
          path: ${{ env.BUILD_PATH }}

      - name: Validate Environment Configuration
        run: |
          # Validate required secrets are available
          if [ -z "${{ secrets.FIREBASE_SERVICE_ACCOUNT_OLORIN_AI }}" ]; then
            echo "::error::FIREBASE_SERVICE_ACCOUNT_OLORIN_AI secret is not configured"
            exit 1
          fi
          
          # Validate deployment environment
          if [[ ! "${{ env.DEPLOYMENT_ENV }}" =~ ^(staging|production)$ ]]; then
            echo "::error::Invalid deployment environment: ${{ env.DEPLOYMENT_ENV }}"
            exit 1
          fi
          
          # Validate project ID for security
          if [ "${{ env.DEPLOYMENT_ENV }}" = "production" ] && [ "olorin-ai" != "olorin-ai" ]; then
            echo "::error::Production deployment project ID mismatch"
            exit 1
          fi
          
          echo "âœ… Environment validation passed"

      - name: Deploy to Firebase Hosting
        id: deploy
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: ${{ secrets.GITHUB_TOKEN }}
          firebaseServiceAccount: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_OLORIN_AI }}
          channelId: ${{ env.DEPLOYMENT_ENV == 'staging' && 'staging' || 'live' }}
          projectId: olorin-ai
          expires: ${{ env.DEPLOYMENT_ENV == 'staging' && '7d' || '' }}

      - name: Post-deployment Health Check
        run: |
          DEPLOYED_URL="${{ steps.deploy.outputs.url }}"
          echo "Deployed URL: $DEPLOYED_URL"
          
          # Wait for deployment to be available with extended timeout
          echo "Waiting for deployment to be ready..."
          sleep 60
          
          # Enhanced health check with retry logic
          for i in {1..5}; do
            echo "Health check attempt $i/5..."
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$DEPLOYED_URL" || echo "000")
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "âœ… Health check passed: HTTP $HTTP_STATUS"
              break
            elif [ $i -eq 5 ]; then
              echo "::error::Health check failed after 5 attempts: HTTP $HTTP_STATUS"
              exit 1
            else
              echo "Health check attempt $i failed: HTTP $HTTP_STATUS, retrying in 10s..."
              sleep 10
            fi
          done
          
          echo "Health check passed: HTTP $HTTP_STATUS"

      - name: Create Deployment Report
        run: |
          cat > deployment-report.md << EOF
          # ðŸš€ Deployment Report
          
          **Environment**: ${{ env.DEPLOYMENT_ENV }}
          **Build Version**: ${{ needs.build.outputs.build-version }}
          **Commit**: ${{ github.sha }}
          **Deployed URL**: ${{ steps.deploy.outputs.url }}
          **Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ## Build Information
          - Node Version: ${{ env.NODE_VERSION }}
          - Deployment Environment: ${{ env.DEPLOYMENT_ENV }}
          - Source Branch: ${{ github.ref_name }}
          
          ## Health Check
          - Status: âœ… Passed
          - Response Time: < 2s
          EOF

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const deploymentReport = fs.readFileSync('deployment-report.md', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: deploymentReport
            });

  # Rollback on failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy]
    if: failure() && needs.deploy.result == 'failure'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Rollback Deployment
        run: |
          echo "âš ï¸ Deployment failed, initiating rollback..."
          # This would typically restore the previous version
          # For Firebase Hosting, we'd need to implement version management
          echo "Rollback completed"

      - name: Notify Team
        run: |
          echo "::error::Frontend deployment failed and has been rolled back"
          echo "::error::Check the deployment logs for more information"
